<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://pclhahaha.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="个人笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;pclhahaha.github.io&#x2F;index.html">
<meta property="og:site_name" content="个人笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://pclhahaha.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>个人笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/03/08/async_programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/08/async_programming/" class="post-title-link" itemprop="url">async_programming</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-08 17:10:20 / 修改时间：17:09:52" itemprop="dateCreated datePublished" datetime="2020-03-08T17:10:20+08:00">2020-03-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA-从异步编程到响应式编程"><a href="#JAVA-从异步编程到响应式编程" class="headerlink" title="JAVA-从异步编程到响应式编程"></a>JAVA-从异步编程到响应式编程</h1><p>Q：响应式编程带来了什么好处？<br>A：当并发连接增加，很多时候我们是通过多线程、线程池的方式来提升性能，然而线程数增加后系统开销也增加了，而且很多场景下线程大部分是执行IO操作，其大部分时间是处于idle状态的，资源利用率不高。响应式编程通过引入非阻塞non-blocking的特性，实现了线程资源的充分利用。</p>
<p>这是一幅盗来的图<a href="https://www.jrebel.com/blog/java-completablefuture-api" target="_blank" rel="noopener">^1</a>，展示了响应式编程的发展历程，尤其是在JVM或者说JAVA领域。这里面比较核心的就是Reactive Streams规范、ReacticeX项目及其包含的RxJava、Project Reactor项目、JAVA方面的CompletableFuture API和Flow API。</p>
<img src="/2020/03/08/async_programming/image-blog-body-completablefuture3.jpg" alt="CompletableFuture API and Reactive Programming Timeline" style="zoom: 67%;">

<h2 id="一、CompletableFuture"><a href="#一、CompletableFuture" class="headerlink" title="一、CompletableFuture"></a>一、CompletableFuture</h2><p>首先，CompletableFuture是Future，意味着它支持任务异步执行。在此基础上，它还支持异步任务之间的依赖关系、异步任务的回调等。对于日常业务逻辑，使用CompletableFuture能够通过将业务逻辑异步化，来提升cpu利用率、缩短响应时间，达到提升性能的目的。</p>
<p>那么CompletableFuture和响应式编程的区别是什么呢？</p>
<p>关键区别在于Stream这个概念上，CompletableFuture描述的是单次执行的结果，尽管可以通过异步任务之间的依赖关系构建一串异步任务组成的执行图，本质上面向的是单次操作，例如一次rpc请求的处理<a href="https://www.jrebel.com/blog/java-completablefuture-api" target="_blank" rel="noopener">^1</a>。</p>
<img src="/2020/03/08/async_programming/image-blog-body-completablefuture2.jpg" alt="Java CompletableFuture API Example Invoice Path" style="zoom:67%;">

<p>响应式编程则面向的是Stream，或者说叫“流”，也即是数据或事件的序列，有点类似JAVA的Stream API。</p>
<p>当然用CompletableFuture也能够实现对数据/事件流的处理，但是有一个关键的特性是响应式编程具备而CompletableFuture则需要重新实现的，并且实现起来很复杂，那就是back pressure。back pressure就是在下游无法承载上游的压力时，采取一些措施。</p>
<p>至于Java中提供的CallBack、Future机制在实现响应式编程中的问题和缺点，例如“callback hell”，不支持lazy computation等，可以从<a href="https://projectreactor.io/docs/core/release/reference/#getting-started中找到答案。" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/#getting-started中找到答案。</a></p>
<p>所以，我们需要一套框架或者说类库来更好的实现响应式编程，需要具备以下特性：</p>
<ul>
<li>支持异步任务的封装及组装，需要API来对异步任务进行包装，并且需要很多种算子来对异步任务进行组装，包括过滤、组装、异常处理等算子</li>
<li>减少异步任务的嵌套，减少代码的复杂性，增加可读性，避免“callback hell”等复杂度很高的代码</li>
<li>支持背压back pressure，也就是下游和上游之间能协商数据流的速度</li>
</ul>
<h2 id="二、响应式编程-从ReactiveX到RxJava"><a href="#二、响应式编程-从ReactiveX到RxJava" class="headerlink" title="二、响应式编程-从ReactiveX到RxJava"></a>二、响应式编程-从ReactiveX到RxJava</h2><p>项目主页：<a href="http://reactivex.io/" target="_blank" rel="noopener">http://reactivex.io/</a></p>
<p>github：<a href="https://github.com/ReactiveX?page=2" target="_blank" rel="noopener">https://github.com/ReactiveX?page=2</a></p>
<p>官网定义如下：</p>
<blockquote>
<p><a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> is a collection of open source projects. The content of this page is licensed under Creative Commons Attribution 3.0 License, and code samples are licensed under the BSD License.</p>
</blockquote>
<blockquote>
<p>ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming</p>
</blockquote>
<blockquote>
<p>ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.</p>
</blockquote>
<p>ReactiveX基于观察者模式、迭代者模式和函数式编程的组合，为构建异步的基于事件的应用提供了一套类库，并且它是一个多语言的项目，例如，JAVA中对应的就是RxJava类库。</p>
<h3 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h3><h4 id="2-1-1-Observable-2"><a href="#2-1-1-Observable-2" class="headerlink" title="2.1.1 Observable^2"></a>2.1.1 Observable<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener">^2</a></h4><img src="/2020/03/08/async_programming/legend.png" alt="img" style="zoom: 50%;">



<p>如上图所示，一个Observable其实就是一个产生数据流的对象，它能够转换为另一个Observable。</p>
<p>Observable可以被Observer订阅（subscribe），一个完整的Observer订阅Observable的例子的伪代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myOnNext     = &#123; item -&gt; <span class="comment">/* do something useful with item */</span> &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myError      = &#123; throwable -&gt; <span class="comment">/* react sensibly to a failed call */</span> &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myComplete   = &#123; <span class="comment">/* clean up after the final response */</span> &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myObservable = someMethod(itsParameters);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(myOnNext, myError, myComplete);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// go on about my business</span></span></pre></td></tr></table></figure>

<p>其中onNext, onError, onComplete三个方法是Observer需要实现的。分别用于对数据流的正常处理，异常处理，完成操作。</p>
<h4 id="2-1-2-Observable的各种算子（Operator）"><a href="#2-1-2-Observable的各种算子（Operator）" class="headerlink" title="2.1.2 Observable的各种算子（Operator）"></a>2.1.2 Observable的各种算子（Operator）</h4><p>算子可用于连接Observable，或者改变Observable的行为。Operator能够将Observable串联起来，形成一条chain。</p>
<p>ReactiveX支持的算子数量较多，这里就不展开了，可以到 <a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">http://reactivex.io/documentation/operators.html</a> 这里查看。</p>
<h4 id="2-1-3-Single"><a href="#2-1-3-Single" class="headerlink" title="2.1.3 Single"></a>2.1.3 Single</h4><p>Single是RxJava中引进的类似Observable，但只产生一个数据的对象，因此订阅它的Observer只需要实现onSuccess，onError方法即可。</p>
<p>Single也有很多对应的算子，可用于创建Single、对Single进行转换、组装、连接、延时等，具体可查看：<a href="http://reactivex.io/documentation/single.html" target="_blank" rel="noopener">http://reactivex.io/documentation/single.html</a></p>
<h4 id="2-1-4-Subject"><a href="#2-1-4-Subject" class="headerlink" title="2.1.4 Subject"></a>2.1.4 Subject</h4><p><a href="http://reactivex.io/documentation/subject.html" target="_blank" rel="noopener">http://reactivex.io/documentation/subject.html</a></p>
<p>一个Subject既是Observable，又是Observer，表明它既可以订阅一个或多个Observable，又可以作为Observable将其订阅到的数据流重新发出，因此它类似一种桥梁或者说代理。</p>
<h4 id="2-1-5-Scheduler"><a href="#2-1-5-Scheduler" class="headerlink" title="2.1.5 Scheduler"></a>2.1.5 Scheduler</h4><p><a href="http://reactivex.io/documentation/scheduler.html" target="_blank" rel="noopener">http://reactivex.io/documentation/scheduler.html</a></p>
<p>Rx默认是单线程的，整条链路上的调用都在Subscribe方法被调用的线程中执行。不过一些算子接收Scheduler作为参数，控制算子在哪个Scheduler上执行，这里可以认为Scheduler是某种线程池，提供了多线程资源。</p>
<p>SubscribeOn算子指定Observable开始执行的线程，而SubscribeOn算子在链路的什么地方被调用并不重要。</p>
<p>ObserveOn算子指定了从该调用开始往后的算子所在的执行线程，如果要改变线程，则需要重新调用ObserveOn，指定一个新的Scheduler。</p>
<h3 id="2-2-RxJava"><a href="#2-2-RxJava" class="headerlink" title="2.2 RxJava"></a>2.2 RxJava</h3><p>github：<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">https://github.com/ReactiveX/RxJava</a></p>
<p>github wiki：<a href="https://github.com/ReactiveX/RxJava/wiki" target="_blank" rel="noopener">https://github.com/ReactiveX/RxJava/wiki</a></p>
<p>RxJava是ReactiveX项目的一部分，它也遵守Reactive Streams规范。不要以为RxJava是只针对Java语言的，RxJava本身也是支持多语言的，支持一堆基于JVM的语言。下面是RxJava的最最最入门级demo，包括Observable的创建，组装，订阅：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavaDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        RxJavaDemo demo = <span class="keyword">new</span> RxJavaDemo();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        demo.hello(<span class="string">"pcl"</span>, <span class="string">"j"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        demo.customObservableBlocking().subscribe(s -&gt; System.out.println(s));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        demo.customObservableNonBlocking().subscribe(s -&gt; System.out.println(s));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        demo.simpleComposition();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * hello world</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String... args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        Flowable.fromArray(args).subscribe(s -&gt; System.out.println(<span class="string">"Hello "</span> + s + <span class="string">"!"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Creating an Observable from an Existing Data Structure</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createObservables</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        Observable&lt;String&gt; o1 = Observable.fromArray(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        Integer[] list = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        Observable&lt;Integer&gt; o2 = Observable.fromArray(list);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        Observable&lt;String&gt; o3 = Observable.just(<span class="string">"one object"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * This example shows a custom Observable that blocks</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * when subscribed to (does not spawn an extra thread).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Observable&lt;String&gt; <span class="title">customObservableBlocking</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> Observable.&lt;String&gt;create(emitter -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                emitter.onNext(<span class="string">"count_"</span> + i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            emitter.onComplete();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 创建一个非阻塞的Observable</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Observable&lt;String&gt; <span class="title">customObservableNonBlocking</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> Observable.&lt;String&gt;create(emitter -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">new</span> Thread() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                        emitter.onNext(<span class="string">"count_"</span> + i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                    emitter.onComplete();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            &#125;.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 用算子对Observable进行组装，或者转变</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">simpleComposition</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        customObservableNonBlocking().skip(<span class="number">10</span>).take(<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">                .map(stringValue -&gt; &#123;<span class="keyword">return</span> stringValue + <span class="string">"_xform"</span>;&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">                .subscribe(s -&gt; System.out.println(<span class="string">"onNext =&gt; "</span> + s));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中simpleComposition()方法的marble diagram如下图所示<a href="https://github.com/ReactiveX/RxJava/wiki/How-To-Use-RxJava" target="_blank" rel="noopener">^3</a>，在reactive编程模型中，常常用marble diagram表示数据流的流转。</p>
<img src="/2020/03/08/async_programming/Composition.1.png" alt="img" style="zoom:25%;">

<h4 id="2-2-1-异常处理"><a href="#2-2-1-异常处理" class="headerlink" title="2.2.1 异常处理"></a>2.2.1 异常处理</h4><p>Observable一般不抛出异常，而是发出一个onError通知，不过有些情况下，例如调用onError()方法本身失败的话，会抛出RuntimeException、OnErrorFailedException、OnErrorNotImplementedException异常。</p>
<p>可以使用异常处理算子来处理onError()方法通知的异常。subscribe的时候可以传入第二个方法处理异常。</p>
<h4 id="2-2-1-RxJava的算子"><a href="#2-2-1-RxJava的算子" class="headerlink" title="2.2.1 RxJava的算子"></a>2.2.1 RxJava的算子</h4><p>只能说RxJava支持的算子很多，就不多说了，当然你也可以自己写新的算子，这就属于比较难的操作了。</p>
<h4 id="2-2-2-back-pressure"><a href="#2-2-2-back-pressure" class="headerlink" title="2.2.2 back pressure"></a>2.2.2 back pressure</h4><p>其实从上面一路写下来，有没有发现RxJava和Stream API非常相似，我是这么觉得的。但是这里就要说一说RxJava所具备的背压这一特性，是响应式编程的非常重要的一个特性。</p>
<p>back pressure就是在下游无法承载上游的压力时，采取一些措施，通知上游放慢速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    source</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    .observeOn(Schedulers.computation())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    .subscribe(v -&gt; compute(v), Throwable::printStackTrace);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        source.onNext(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    Thread.sleep(<span class="number">10_000</span>);</span></pre></td></tr></table></figure>

<p>这段代码会抛出MissingBackpressureException异常，因为PublishProcessor不支持背压，而observeOn算子内部的buffer是有边界的，当PublishProcessor产生数据的速度超过计算的速度时，数据会存在observeOn的内部buffer中，当溢出时就抛出MissingBackpressureException异常。</p>
<p>如果改成下面的代码则可以正常运行，因为Flowable.range支持背压，range可以和observeOn之间通过类似协程的机制，协商应该以什么样的速度产生数据。具体的机制是，range通过调用observeOn的onSubscribe方法发送一个callback方法（org.reactivestreams.Subscription接口的实现）给订阅者，observeOn回调Subscription.request(n)方法告诉range产生n个数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Flowable.range(<span class="number">1</span>, <span class="number">1_000_000</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">.observeOn(Schedulers.computation())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.subscribe(v -&gt; compute(v), Throwable::printStackTrace);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">10_000</span>);</span></pre></td></tr></table></figure>

<p>下面通过一个更显式的例子来说明，先调用onStart方法要求range发送一个数据，然后异步调用onNext方法进行数据计算，并再发一个request要求一个数据，注意onStart中request执行完后，range就会发送数据，会异步触发onNext，若此时onStart中初始化操作尚未完成，则可能产生异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Flowable.range(<span class="number">1</span>, <span class="number">1_000_000</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">                .subscribe(<span class="keyword">new</span> DisposableSubscriber&lt;Integer&gt;() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">                    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                        request(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer v)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                        v = v * <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                        System.out.println(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                        request(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable ex)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                        ex.printStackTrace();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                        System.out.println(<span class="string">"Done!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr></table></figure>

<h5 id="2-2-2-1-解决背压问题-增加buffer-size"><a href="#2-2-2-1-解决背压问题-增加buffer-size" class="headerlink" title="2.2.2.1 解决背压问题-增加buffer size"></a>2.2.2.1 解决背压问题-增加buffer size</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    source.observeOn(Schedulers.computation(), <span class="number">1024</span> * <span class="number">1024</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">          .subscribe(e -&gt; &#123; &#125;, Throwable::printStackTrace);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        source.onNext(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>仍然有机会产生MissingBackpressureException</p>
<h5 id="2-2-2-2-解决背压问题-批量算子-采样算子"><a href="#2-2-2-2-解决背压问题-批量算子-采样算子" class="headerlink" title="2.2.2.2 解决背压问题-批量算子/采样算子"></a>2.2.2.2 解决背压问题-批量算子/采样算子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    source</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">          .buffer(<span class="number">1024</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">          .observeOn(Schedulers.computation(), <span class="number">1024</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">          .subscribe(list -&gt; &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">              list.parallelStream().map(e -&gt; e * e).first();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">          &#125;, Throwable::printStackTrace);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        source.onNext(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    source</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">          .sample(<span class="number">1</span>, TimeUnit.MILLISECONDS)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">          .observeOn(Schedulers.computation(), <span class="number">1024</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">          .subscribe(v -&gt; compute(v), Throwable::printStackTrace);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        source.onNext(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>仍然有机会产生MissingBackpressureException</p>
<h5 id="2-2-2-3-解决背压问题-onBackpressureXXX-算子"><a href="#2-2-2-3-解决背压问题-onBackpressureXXX-算子" class="headerlink" title="2.2.2.3 解决背压问题-onBackpressureXXX 算子"></a>2.2.2.3 解决背压问题-onBackpressureXXX 算子</h5><p>onBackpressureBuffer()<br>onBackpressureBuffer(int capacity)<br>onBackpressureBuffer(int capacity, Action onOverflow)<br>onBackpressureBuffer(int capacity, Action onOverflow, BackpressureOverflowStrategy strategy)<br>onBackpressureDrop()<br>onBackpressureLatest()</p>
<p>还有一个办法是创建支持背压的数据源。</p>
<h2 id="三、响应式编程-从Reactive-Streams到Project-Reactor"><a href="#三、响应式编程-从Reactive-Streams到Project-Reactor" class="headerlink" title="三、响应式编程-从Reactive Streams到Project Reactor"></a>三、响应式编程-从Reactive Streams到Project Reactor</h2><p>上文提到RxJava属于ReactiveX项目，也遵守Reactive Streams规范，这里就介绍一下Reactive Streams规范，以及在其基础上的Project Reactor。</p>
<h3 id="3-1-Reactive-Streams"><a href="#3-1-Reactive-Streams" class="headerlink" title="3.1 Reactive Streams"></a>3.1 Reactive Streams</h3><p>主页：<a href="https://www.reactive-streams.org/" target="_blank" rel="noopener">https://www.reactive-streams.org/</a></p>
<blockquote>
<p>Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.</p>
</blockquote>
<p>Reactive Streams是一套规范，为异步流处理及非阻塞的背压提供了标准。</p>
<p>对于Java程序员，Reactive Streams是一个API。Reactive Streams为我们提供了Java中的Reactive Programming的通用API。<code>Reactive Streams API</code>中仅仅包含了如下四个接口<a href="https://zhuanlan.zhihu.com/p/95966853" target="_blank" rel="noopener">^4</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span>  <span class="title">Publisher</span> &lt; <span class="title">T</span> &gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span>  subscribe（Subscriber &lt;？<span class="keyword">super</span>  T &gt;  s）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅者</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span>  <span class="title">Subscriber</span> &lt; <span class="title">T</span> &gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span>  onSubscribe（Subscription  s）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span>  onNext（T  t）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span>  onError（Throwable  t）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span>  onComplete（）;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示Subscriber消费Publisher发布的一个消息的生命周期</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理器，表示一个处理阶段，它既是订阅者也是发布者，并且遵守两者的契约</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt;, <span class="title">Publisher</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">https://github.com/reactive-streams/reactive-streams-jvm</a> 定义了Reactive Streams的JVM规范。</p>
<p><strong>Java9中Flow类下的内容与Reactive Streams完全一致，这部分留到后面研究。</strong></p>
<p>其他还有AKKA Streams支持Reactive Streams。</p>
<p>Publisher-Subscriber接口既有观察者模式，又包含了迭代器模式。Subscriber通过订阅的方式实现了观察者模式。由Publisher通过push元素实现对元素的迭代，而相应的Java中的Iterator是通过pull的方式实现迭代。push的方式是响应式编程的关键，Publisher通过调用Subscriber的onNext方法通知Subscriber下一个元素，通过onError通知异常，通过onComplete通知完成。</p>
<h3 id="3-2-Project-Reactor"><a href="#3-2-Project-Reactor" class="headerlink" title="3.2 Project Reactor"></a>3.2 Project Reactor</h3><p>主页：<a href="https://projectreactor.io/" target="_blank" rel="noopener">https://projectreactor.io/</a></p>
<blockquote>
<p>Reactor is a fourth-generation reactive library, based on the <a href="https://github.com/reactive-streams/reactive-streams-jvm" target="_blank" rel="noopener">Reactive Streams</a><br>specification, for building non-blocking applications on the JVM</p>
</blockquote>
<p>Reactor文档：</p>
<p><a href="https://projectreactor.io/docs/core/release/reference/" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/</a></p>
<p>Reactor Core运行需要Java8+环境，可以直接和Java8的函数式API交互，包括CompletableFuture，Stream和Duration。它实现了Reactive Streams规范，并提供Flux和Mono两个异步序列API，Flux是支持N个元素的序列，Mono是支持0个或1个的序列（类似RxJava中的Single）。<strong>reactor-netty</strong>项目支持非阻塞的IPC(inter-process communication)，它还提供了支持HTTP(包括WebSockets)、TCP、UDP协议的带有背压特性的网络引擎，支持响应式的边界码，适合微服务框架。</p>
<p>Reactor实现了Reactive Streams规范，因此实现了Publisher, Subscriber接口。需要注意的一点是Publisher创建后，并不开始产生数据，各种算子对Publisher的包装也不会导致数据开始产生，只有当调用链由Subscriber订阅后，内部调用request方法才会触发数据开始流动。</p>
<p>Reactor背压的实现机制和RxJava类似。也是通过上面提到的request机制来进行协商。</p>
<h4 id="3-2-1-Flux与Mono"><a href="#3-2-1-Flux与Mono" class="headerlink" title="3.2.1 Flux与Mono"></a>3.2.1 Flux与Mono</h4><p>Flux与Mono是Publisher的实现，其创建代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createFluxMono</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        Flux&lt;String&gt; seq1 = Flux.just(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"foobar"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        List&lt;String&gt; iterable = Arrays.asList(<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"foobar"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        Mono&lt;String&gt; noData = Mono.empty();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        Mono&lt;String&gt; data = Mono.just(<span class="string">"foo"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(<span class="number">5</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>其subscribe代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  			<span class="comment">//最后一个函数表示对每一个元素执行的操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Flux&lt;Integer&gt; ints1 = Flux.range(<span class="number">1</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        ints1.subscribe(i -&gt; System.out.println(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">//最后一个函数表示异常时执行的操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        Flux&lt;Integer&gt; ints2 = Flux.range(<span class="number">1</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                .map(i -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (i &lt;= <span class="number">3</span>) <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Got to 4"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        ints2.subscribe(i -&gt; System.out.println(i),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                error -&gt; System.err.println(<span class="string">"Error: "</span> + error));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">//最后一个函数表示完成时执行的操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        Flux&lt;Integer&gt; ints3 = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        ints3.subscribe(i -&gt; System.out.println(i),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                () -&gt; System.out.println(<span class="string">"Done"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  			<span class="comment">//最后一个函数表示订阅时执行的操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  			Flux&lt;Integer&gt; ints4 = Flux.range(<span class="number">1</span>, <span class="number">4</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        ints4.subscribe(i -&gt; System.out.println(i),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                error -&gt; System.err.println(<span class="string">"Error "</span> + error),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                () -&gt; System.out.println(<span class="string">"Done"</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                sub -&gt; sub.request(<span class="number">2</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>以上是Reactor的一些基操，其他部分的内容包括算子的使用、背压的实现、异步的实现、异常处理、测试、Debug以及一些高级特性等，建议还是看官方文档，不是一篇文章能讲完的。</p>
<p>总的来说，Reactor的实现和RxJava在很多方面是相似的。</p>
<h3 id="3-3-Spring-WebFlux"><a href="#3-3-Spring-WebFlux" class="headerlink" title="3.3 Spring WebFlux"></a>3.3 Spring WebFlux</h3><img src="/2020/03/08/async_programming/diagram-reactive-1290533f3f01ec9c57baf2cc9ea9fa2f-20200306130014908.svg" alt="Spring Reactive diagram">

<p>在Project Reactor提供的类库的基础上，Spring构建了自己的reactive技术栈。Spring WebFlux可以运行在Netty, Undertow服务器上或者Servlet 3.1+ 的web容器中。</p>
<p>再一次推荐官方文档：</p>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/02/09/java_concurrent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/09/java_concurrent/" class="post-title-link" itemprop="url">JAVA并发基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-09 21:24:59 / 修改时间：21:24:14" itemprop="dateCreated datePublished" datetime="2020-02-09T21:24:59+08:00">2020-02-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="JAVA并发基础"><a href="#JAVA并发基础" class="headerlink" title="JAVA并发基础"></a>JAVA并发基础</h1><h2 id="一、多线程基础"><a href="#一、多线程基础" class="headerlink" title="一、多线程基础"></a>一、多线程基础</h2><h3 id="1-多线程的风险"><a href="#1-多线程的风险" class="headerlink" title="1. 多线程的风险"></a>1. 多线程的风险</h3><ul>
<li>安全性问题：竞态条件race condition、指令重排序等</li>
<li>活跃性问题：死锁、饥饿、活锁</li>
<li>性能问题：上下文切换、同步机制抑制编译器优化，使内存缓存数据无效，增加共享内存总线的同步流量</li>
</ul>
<h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2. 线程安全性"></a>2. 线程安全性</h3><p>线程安全本质上就是对共享且可变的状态进行安全的访问，共享指可以被多个线程访问，可变指状态可以被修改。线程安全有以下特性：</p>
<ul>
<li>无状态的对象一定是线程安全的</li>
<li>不可变对象一定是线程安全的</li>
<li>有状态的可变对象在并发情况下存在竞态条件，即多个线程可能同时修改同一个变量，可通过原子操作或锁实现线程安全</li>
<li><strong>原子性</strong>：对状态的原子性操作可以保证线程安全，例如jdk自带的原子类，或者加锁</li>
<li>锁：通过加锁/解锁操作避免竞态条件，保证原子性，java中的锁有：内部锁/监视器锁（synchronized关键字），监视器锁是可重入的，通过在锁对象上的一个计数器实现；显式锁</li>
</ul>
<h4 id="2-1-原子性、可见性、顺序性"><a href="#2-1-原子性、可见性、顺序性" class="headerlink" title="2.1 原子性、可见性、顺序性"></a>2.1 原子性、可见性、顺序性</h4><ul>
<li>原子性上面已经提到过，主要是解决了并发情况下的竞态条件</li>
<li>可见性：同步带来的另一个好处是内存可见性，可以避免并发情况下的过期数据、非原子的64位操作等问题</li>
<li>过期数据问题：例如，指令指令重排序会造成一个线程读取到的共享变量是过期的，指令重排序本质上是一个<strong>顺序性</strong>问题；还有一种可能是CPU多级缓存和内存间的不一致造成读到过期数据</li>
<li>非原子的64位操作问题：当读写非volatile的double或long时，若处理器不支持64位算数原子操作，JVM允许将其分为两个32位的操作，如果没有通过加volatile关键字或没有加同步锁保护，那么可能得到一个值的高32位和另一个值的低32位</li>
<li><strong>volatile只能保证可见性，加锁可以保证可见性与原子性</strong></li>
<li>以上提到的原子性、可见性、顺序性问题，会在下一节对JMM的描述中展开来说</li>
</ul>
<h4 id="2-2-对象的发布publish与逸出escape"><a href="#2-2-对象的发布publish与逸出escape" class="headerlink" title="2.2 对象的发布publish与逸出escape"></a>2.2 对象的发布publish与逸出escape</h4><p>一个对象能被外部代码使用称为发布，未准备好的对象被发布称为逸出，例如，未构造完毕的对象被传递给外部引用，对象的发布需要注意以下问题：</p>
<ul>
<li><p>不要让this引用在构造期间逸出，this引用在构造期间逸出可能导致对象未构造完毕即能被使用</p>
</li>
<li><p>局部创建对象：例如，多线程共享的对象，构造时由于可见性的问题，可能只完成了部分创建，即其他线程看见的是未完成构造的对象，例如：在double-check-locking(DCL)机制实现的懒汉单例模式中，如果instance变量不加volatile关键字，那么由于步骤(5)对象初始化并赋值给引用过程的指令重排序，可能造成instance指向的是未创建完成的对象时被另一个线程使用，代码如下<a href="https://www.jianshu.com/p/ca19c22e02f4" target="_blank" rel="noopener">^5</a>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.id= <span class="keyword">new</span> Random().nextInt(<span class="number">200</span>)+<span class="number">1</span>;                 <span class="comment">// (1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                               <span class="comment">// (2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">synchronized</span>(LazySingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;               <span class="comment">// (3)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                       <span class="comment">// (4)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();           <span class="comment">// (5)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> instance;                                      <span class="comment">// (6)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> id;                                            <span class="comment">// (7)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="2-3-变量的线程封闭"><a href="#2-3-变量的线程封闭" class="headerlink" title="2.3 变量的线程封闭"></a>2.3 变量的线程封闭</h4><p>不需要共享的变量可通过线程封闭来实现线程安全，这样对象不会被其他线程访问到，即不发布对象。</p>
<ul>
<li>规范的方式是使用ThreadLocal：线程首次调用ThreadLocal.get方法时，会请求initialValue提供一个初始值</li>
</ul>
<h4 id="2-4-不可变性"><a href="#2-4-不可变性" class="headerlink" title="2.4 不可变性"></a>2.4 不可变性</h4><ul>
<li>不可变对象的条件：不可修改的状态，所有field都是final类型的，正确的构造（没有在构造时发生this引用的逸出）。不可变对象天生是线程安全的。</li>
<li>不可变对象保证了初始化安全性，因为final关键字确保了初始化安全性，即对象发布时不会发生局部创建对象的问题，即保证了可见性</li>
<li>使用volatile发布不可变对象，可实现线程安全，即使用一个不可变对象保存所有变量，而用一个volatile引用指向不可变对象，当需要更新时，直接替换不可变对象，保证了可见性与原子性</li>
</ul>
<h4 id="2-5-对象的安全发布"><a href="#2-5-对象的安全发布" class="headerlink" title="2.5 对象的安全发布"></a>2.5 对象的安全发布</h4><p>非不可变对象需要被安全的发布，对象的安全发布意味着对象的状态必须在被其他线程（除发布线程）引用的同时可见，一个正确创建的对象可以通过以下方式安全发布：</p>
<ul>
<li>通过静态初始化器初始化对该对象的引用，利用JVM在类加载时的同步机制保证安全发布</li>
<li>将该对象的引用存储到volatile域或AutomicReference：volatile保证了对象的可见性，AutomicReference保证对该对象的操作满足原子性，即存在同步机制，这里说下个人理解：原子性保证了可见性，如果可见性无法保证，那么原子性也无法实现</li>
<li>将该对象的引用存储到正确创建的对象的final域中：final保证了不可变性</li>
<li>将该对象的引用存储到由锁正确保护的域中，例如线程安全的容器类，其他线程在获取放入容器的对象时可以通过同步机制保证对象的安全发布</li>
</ul>
<h3 id="3-基本组件"><a href="#3-基本组件" class="headerlink" title="3. 基本组件"></a>3. 基本组件</h3><h4 id="3-1-同步容器"><a href="#3-1-同步容器" class="headerlink" title="3.1 同步容器"></a>3.1 同步容器</h4><ul>
<li>Vector、HashTable、Collections.synchronizedXxx</li>
<li>对同步容器的复合操作，例如，put-if-abscent语义的手动实现是不保证线程安全的</li>
<li>迭代器使用过程中如果容器被修改会抛出ConcurrentModificationException，它是fail-fast的，通过维护一个计数器，当计数器被修改则抛出异常</li>
<li>隐藏迭代器：容器的toString、hashCode、equals的方法，容器本身作为元素或作为另一个容器的key时，containsAll、removeAll、retainAll方法以及把容器做为构造函数参数，都会隐式迭代，可能抛出异常</li>
</ul>
<h4 id="3-2-并发容器"><a href="#3-2-并发容器" class="headerlink" title="3.2 并发容器"></a>3.2 并发容器</h4><ul>
<li>ConcurrentHashMap：提供了不会抛出ConcurrentModificationException的迭代器；附加了put-if-abscent、remove-if-equal、replace-if-equal的原子操作</li>
<li>ConcurrentSkipListMap, ConcurrentSkipListSet</li>
<li>CopyOnWriteArrayList, CopyOnWriteArraySet：copy-on-write容器在每次需要修改时创建并重新发布一个新的容器拷贝</li>
<li>ConcurrentLinkedQueue</li>
</ul>
<h4 id="3-3-阻塞队列与生产者-消费者模式"><a href="#3-3-阻塞队列与生产者-消费者模式" class="headerlink" title="3.3 阻塞队列与生产者-消费者模式"></a>3.3 阻塞队列与生产者-消费者模式</h4><ul>
<li>LinkedBlockingQueue, ArrayBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue：不存储队列元素，适合消费者充足的场景</li>
</ul>
<h4 id="3-4-双端队列与工作窃取"><a href="#3-4-双端队列与工作窃取" class="headerlink" title="3.4 双端队列与工作窃取"></a>3.4 双端队列与工作窃取</h4><p>这个在Fork/Join框架中展开。</p>
<h4 id="3-5-阻塞和可中断的方法"><a href="#3-5-阻塞和可中断的方法" class="headerlink" title="3.5 阻塞和可中断的方法"></a>3.5 阻塞和可中断的方法</h4><p>线程阻塞挂起时，被设置成某个状态（BLOCKED, WAITING, TIMED_WAITING）。</p>
<p>BlockingQueue的put和take方法会抛出一个InterruptedException，Thread.sleep也会抛出这个异常，当一个方法能够抛出这个异常，说明这是一个可阻塞的方法，并且如果被中断，可以提前结束阻塞状态。Thread提供interrupt方法，用来中断一个线程或者查询某线程是否已被中断，具体实现是：线程维护一个bool类型属性，代表中断状态，中断时设置这个值。</p>
<h4 id="3-6-Synchronizer"><a href="#3-6-Synchronizer" class="headerlink" title="3.6 Synchronizer"></a>3.6 Synchronizer</h4><ul>
<li>latch闭锁：用于保证特定活动直到其他活动结束后才开始。CountDownLatch是一个实现。</li>
<li>FutureTask：描述一个可携带结果的计算，通过Callable执行计算，通过Future.get获取结果或者异常，异常统一封装为ExecutionException，如果计算被取消，返回CancellationException。</li>
<li>信号量Semaphore：用来控制能够同时访问某资源的并发数量，可用于实现资源池或者给容器限定边界</li>
<li>关卡barrier：用于限制所有线程同时到达关卡点。CyclicBarrier，Exchanger是具体实现。</li>
</ul>
<p>CountDownLatch基于AQS实现，CyclicBarrier基于ReentrantLock，而ReentrantLock基于AQS实现。AQS提供了一个基于队列的同步器框架，许多同步器可以基于AQS实现，AQS的原理在第五节详细展开描述。</p>
<h2 id="二、Java内存模型-Java-Memory-Model"><a href="#二、Java内存模型-Java-Memory-Model" class="headerlink" title="二、Java内存模型 (Java Memory Model)"></a>二、Java内存模型 (Java Memory Model)</h2><p>在可共享内存的多处理器架构中，存在CPU多级缓存与内存的缓存一致性问题，不同的架构由不同的缓存一致性协议，本质上是通过内存屏障来实现。另外还有指令重排序问题，指令重排序提升了性能，然而在多线程环境中如果无法确认代码的执行顺序，就无法确认代码的正确性。</p>
<p>JMM(Java Memory Model)通过提供自己的存储模型，屏蔽了java虚拟机与底层硬件存储模型的差异化，在语言层面定义了<strong>内存屏障</strong>，用来屏蔽不同硬件存储模型的内存屏障的不同实现。</p>
<h3 id="1-从硬件平台的存储模型到Java存储模型"><a href="#1-从硬件平台的存储模型到Java存储模型" class="headerlink" title="1. 从硬件平台的存储模型到Java存储模型"></a>1. 从硬件平台的存储模型到Java存储模型</h3><h4 id="1-1-缓存一致性问题-cache-coherence"><a href="#1-1-缓存一致性问题-cache-coherence" class="headerlink" title="1.1 缓存一致性问题 cache coherence"></a>1.1 缓存一致性问题 cache coherence</h4><p><img src="/2020/02/09/java_concurrent/d69cecab903313c776b50de1c43050bc31123.png" alt="处理器Cache模型"></p>
<p>CPU一般有多级缓存，与主内存之间通过同步协议保证一致性，比较经典的是MESI协议，参考<a href="https://blog.csdn.net/muxiqingyang/article/details/6615199、https://www.cnblogs.com/yanlong300/p/8986041.html。" target="_blank" rel="noopener">https://blog.csdn.net/muxiqingyang/article/details/6615199、https://www.cnblogs.com/yanlong300/p/8986041.html。</a></p>
<h4 id="1-2-指令重排序"><a href="#1-2-指令重排序" class="headerlink" title="1.2 指令重排序"></a>1.2 指令重排序</h4><p>指令重排序可能是编译器指令重排序（编译器级别）或CPU指令重排序（处理器级别，out-of-order execution），指令重排序可以使计算性能得到提升。<br>即使指令没有重排序，由于CPU缓存的存在，缓存刷新至内存的时许不同也会导致重排序问题。</p>
<h4 id="1-3-memory-barrier-内存屏障"><a href="#1-3-memory-barrier-内存屏障" class="headerlink" title="1.3 memory barrier 内存屏障"></a>1.3 memory barrier 内存屏障</h4><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p>
<p>内存屏障可以被分为以下几种类型：</p>
<ul>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li>
</ul>
<p><img src="/2020/02/09/java_concurrent/bde75d1129494bf77b8b8b1ade546cd276768.png" alt="内存屏障示意表"></p>
<p>以上关于指令重排序、内存屏障的描述参考了<a href="https://tech.meituan.com/2014/09/23/java-memory-reordering.html，希望深入的了解的可直接阅读原文。" target="_blank" rel="noopener">https://tech.meituan.com/2014/09/23/java-memory-reordering.html，希望深入的了解的可直接阅读原文。</a></p>
<h4 id="1-4-Java存储模型的happens-before法则-4"><a href="#1-4-Java存储模型的happens-before法则-4" class="headerlink" title="1.4 Java存储模型的happens-before法则^4"></a>1.4 Java存储模型的happens-before法则<a href="https://www.jianshu.com/p/b9186dbebe8e" target="_blank" rel="noopener">^4</a></h4><p>JMM为程序中的所有动作定义了一种happens-before关系，两个操作如果满足happens-before关系，则前者的结果一定对后者可见，保证了顺序性及可见性，而不满足happens-before关系的动作之间可以任意重排序。</p>
<ul>
<li>程序次序法则：同一线程中，代码中先出现的动作happens-before代码中后出现的动作，这只保证最终执行结果与顺序执行一致，并不能保证指令不重排序，只是结果上表现为happens-before。这个可以解释为，同一线程中前面的写操作对后面操作可见。</li>
<li>监视器锁法则：对同一个监视器锁的解锁happens-before后续对该锁的加锁，显式锁同样适用。</li>
<li>volatile法则：对volatile修饰的域的写happens-before后续对其的读操作，原子变量同样适用。</li>
<li>线程启动法则：一个线程内，对Thread.start的调用happens-before每一个被启动线程中的动作。</li>
<li>线程终结法则：线程中的任何动作happens-before其他线程监测到这个线程已经终结，或者从Thread.join调用中成功返回，或者Thread.isAlive返回false</li>
<li>中断法则：一个线程调用另一个线程的interrupt happens-before被中断的线程发现中断</li>
<li>终结法则：一个对象的构造函数的结束happens-before这个对象的finalizer的开始</li>
<li>传递性：如果A happens-before B，且B happens-before C，则A happens-before C</li>
</ul>
<p>基于happens-before可以推断出多线程情况下代码的执行顺序，当然如果正确没有使用相应的同步机制，大部分操作是无法推断的😣。</p>
<h4 id="1-5-volatile、synchorized、final-3"><a href="#1-5-volatile、synchorized、final-3" class="headerlink" title="1.5 volatile、synchorized、final^3"></a>1.5 volatile、synchorized、final<a href="https://blog.csdn.net/chenxiaoti/article/details/82776128" target="_blank" rel="noopener">^3</a></h4><ul>
<li>volatile关键字：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</li>
<li>synchorized关键字：同步块的可见性是由以下机制保证的：<br>“如果对一个变量执行lock操作，将会清空工作内存中变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”<br>“对一个变量执行unlock操作之前，必须先把此变量的值同步到主内存中（执行store和write操作）</li>
<li>final关键字：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步）</li>
</ul>
<h3 id="2-CPU缓存的伪共享问题"><a href="#2-CPU缓存的伪共享问题" class="headerlink" title="2. CPU缓存的伪共享问题"></a>2. CPU缓存的伪共享问题</h3><p>CPU缓存的最小单位是缓存行 (Cache Line) ，一个缓存行的大小通常是 64 字节（取决于 CPU），它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。</p>
<p>假设两个线程A和B运行在两个CPU上，每个CPU都有一个缓存行中存放了两个volatile long类型的变量X和Y，A更新X后，由于X是volatile的，B所在CPU的缓存行就失效了，需要重新加载，即使B想要更新的是Y，两者逻辑上不存在竞争关系，但在缓存行这个层次上发生了冲突。这是一个伪共享问题的典型场景。</p>
<p>上述场景中，假如A和B交替执行，那么伪共享问题一直发生，对性能影响会很大。</p>
<h4 id="2-1-sun-misc-Contended注解"><a href="#2-1-sun-misc-Contended注解" class="headerlink" title="2.1 @sun.misc.Contended注解"></a>2.1 @sun.misc.Contended注解</h4><p>在Java 7之前，可以在属性的前后进行padding来避免伪共享问题。</p>
<p>在Java 8中，提供了@sun.misc.Contended注解来避免伪共享，原理是在使用此注解的对象或字段的前后各增加128字节大小的padding，使用2倍于大多数硬件缓存行的大小来避免相邻扇区预取导致的伪共享冲突。</p>
<p>以上关于伪共享问题的内容参考了<a href="https://www.jianshu.com/p/c3c108c3dcfd。" target="_blank" rel="noopener">https://www.jianshu.com/p/c3c108c3dcfd。</a></p>
<h3 id="3-重新理解对象的安全发布与初始化安全性"><a href="#3-重新理解对象的安全发布与初始化安全性" class="headerlink" title="3. 重新理解对象的安全发布与初始化安全性"></a>3. 重新理解对象的安全发布与初始化安全性</h3><p>在了解了JMM之后，可以回顾一下之前提到的对象的安全发布以及初始化安全性。</p>
<p>理解对象安全发布的一个很好的例子就是懒汉单例模式（当然现在已经不推荐使用懒汉单例模式了，它复杂且节约的性能有限），理解为何instance变量必须被volatile修饰才能保证安全。推荐思考一下。</p>
<h2 id="三、原子变量类"><a href="#三、原子变量类" class="headerlink" title="三、原子变量类"></a>三、原子变量类</h2><h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>Java内部很多机制以及很多标准类库中都用到了CAS机制，Java的CAS操作依赖硬件对CAS的支持，主流处理器基本都有自己的CAS实现。使用CAS相比于使用锁，可以减少线程上下文切换，减小竞争的颗粒度，一般来说性能优于锁，但是基于CAS的无锁算法实现上会更复杂，相关例子可以参考ConcurrentLinkedQueue的算法。</p>
<h3 id="2-原子变量类"><a href="#2-原子变量类" class="headerlink" title="2. 原子变量类"></a>2. 原子变量类</h3><p>原子变量类保证了可见性与原子性，相比volatile只能保证可见性，功能更为强大。以下是一些常用的原子变量类。</p>
<table>
<thead>
<tr>
<th>原子变量类</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>AtomicBoolean</td>
<td>原子化的boolean</td>
</tr>
<tr>
<td>AtomicInteger、AtomicLong</td>
<td>原子化的int、long</td>
</tr>
<tr>
<td>AtomicIntegerArray、AtomicLongArray</td>
<td>数组内的元素可以原子化的更新</td>
</tr>
<tr>
<td>AtomicReference</td>
<td>可以被原子化更新的对象引用</td>
</tr>
<tr>
<td>AtomicReferenceArray</td>
<td></td>
</tr>
<tr>
<td>AtomicStampedReference、AtomicMarkableReference</td>
<td>支持原子化的更新引用及附带的stamp integer或mark bit，相当于版本号，可防止ABA问题</td>
</tr>
<tr>
<td>DoubleAccumulator、LongAccumulator</td>
<td></td>
</tr>
<tr>
<td>DoubleAdder、LongAdder</td>
<td></td>
</tr>
</tbody></table>
<p>另外还要介绍一下原子化的域更新器：</p>
<table>
<thead>
<tr>
<th>原子化的域更新器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>AtomicIntegerFieldUpdater</td>
<td>原子化的更新指定类的volatile int 变量</td>
</tr>
<tr>
<td>AtomicLongFieldUpdater</td>
<td>原子化的更新指定类的volatile long 变量</td>
</tr>
<tr>
<td>AtomicReferenceFieldUpdater</td>
<td>原子化的更新指定类的volatile引用的field</td>
</tr>
</tbody></table>
<h2 id="四、锁"><a href="#四、锁" class="headerlink" title="四、锁"></a>四、锁</h2><h3 id="1-synchronized关键字"><a href="#1-synchronized关键字" class="headerlink" title="1. synchronized关键字"></a>1. synchronized关键字</h3><p>关于synchronized关键字的文章已经比较多了，可参考以下文章：</p>
<ul>
<li><p>偏置锁</p>
<p><a href="https://blogs.oracle.com/dave/biased-locking-in-hotspot" target="_blank" rel="noopener">https://blogs.oracle.com/dave/biased-locking-in-hotspot</a></p>
<p><a href="https://www.usenix.org/legacy/event/jvm01/full_papers/dice/dice.pdf" target="_blank" rel="noopener">https://www.usenix.org/legacy/event/jvm01/full_papers/dice/dice.pdf</a></p>
</li>
<li><p>synchronized关键字的全面描述，包括偏置锁相关的内容</p>
<p><a href="https://www.cnblogs.com/javaminer/p/3889023.html" target="_blank" rel="noopener">https://www.cnblogs.com/javaminer/p/3889023.html</a></p>
<p><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">https://blog.csdn.net/u012465296/article/details/53022317</a></p>
<p><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/54883355</a></p>
</li>
</ul>
<h3 id="2-Lock"><a href="#2-Lock" class="headerlink" title="2. Lock"></a>2. Lock</h3><h4 id="2-1-ReentrantLock"><a href="#2-1-ReentrantLock" class="headerlink" title="2.1 ReentrantLock"></a>2.1 ReentrantLock</h4><p>ReentrantLock是Lock接口的实现，ReentrantLock支持与synchronized一样的语义，包括可重入性，之所以创建ReentrantLock这么一个显式锁机制，主要是synchronized存在一些局限性，例如：无法在获取锁时取消或设置超时或获取失败立即返回，不支持公平锁（虽然绝大多数情况下出于性能考虑使用非公平锁）等。需要注意的是ReentrantLock和synchronized的性能上差距很小，因此出于简化程序的目的，应尽量避免使用ReentrantLock。</p>
<p>Lock的使用规范如下，一定要在finally块中释放锁，否则可能由于异常导致锁无法释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoMethod</span><span class="params">()</span> </span>&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// ... method body</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">       lock.unlock()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>ReentrantLock底层是基于AQS实现的，具体在第五节中描述。</p>
<h4 id="2-2-ReadWriteLock与ReentrantReadWriteLock"><a href="#2-2-ReadWriteLock与ReentrantReadWriteLock" class="headerlink" title="2.2 ReadWriteLock与ReentrantReadWriteLock"></a>2.2 ReadWriteLock与ReentrantReadWriteLock</h4><p>ReentrantReadWriteLock是ReadWriteLock接口的实现，是一个读写锁，在读多写少的并发场景下，使用读写锁可以提升性能。ReentrantReadWriteLock有以下特性：</p>
<ul>
<li>写锁可以降级为读锁，读锁不能升级为写锁</li>
<li>写锁是互斥的，读锁是共享的</li>
</ul>
<p>ReentrantReadWriteLock底层是基于AQS实现的，它使用AQS的state变量的高16位用作读锁，低16位用作写锁。</p>
<h3 id="3-条件队列"><a href="#3-条件队列" class="headerlink" title="3. 条件队列"></a>3. 条件队列</h3><p>线程在某个条件不满足的情况下进入条件队列并释放锁，由另一个线程在某个条件满足的情况下唤醒处于条件队列中的线程。类似于提供了synchronized和Lock两种锁的实现，Java也提供了两种条件队列的实现。</p>
<table>
<thead>
<tr>
<th>Object的内部条件队列</th>
<th>Lock的Condition</th>
</tr>
</thead>
<tbody><tr>
<td>Object的wait、notify、notifyAll方法</td>
<td>Condition的await、signal、signalAll方法</td>
</tr>
<tr>
<td>一个对象只有一个内部条件队列，多个条件的情况下使用一个对象进行wait、notify、notifyAll操作</td>
<td>一个Lock可以new多个Condition，对应不同的条件，分别进行await、signal、signalAll操作</td>
</tr>
</tbody></table>
<p>注意Condition只是一个接口，需要Lock的具体实现类的newCondition方法提供实现。ReentrantLock的newCondition方法返回的是一个AQS中的ConditionObject类型的对象，第五节中会对ConditionObject的原理有解释，可以看到是通过一个链表实现的条件队列。</p>
<p>Condition的官方使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> Condition notFull  = &lt;b&gt;lock.newCondition(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> Condition notEmpty = &lt;b&gt;lock.newCondition(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> putptr, takeptr, count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">     lock.lock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">while</span> (count == items.length)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">         &lt;b&gt;notFull.await();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">       items[putptr] = x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">       ++count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">       notEmpty.signal();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">       lock.unlock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">     lock.lock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">while</span> (count == <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">         notEmpty.await();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">       Object x = items[takeptr];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">       --count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">       notFull.signal();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">       lock.unlock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<h3 id="4-关于锁的总结"><a href="#4-关于锁的总结" class="headerlink" title="4. 关于锁的总结"></a>4. 关于锁的总结</h3><p>参考文献【1】<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">^1</a>做了非常好的总结，推荐直接阅读该文章。 </p>
<h2 id="五、AQS-AbstractQueuedSynchronizer-原理及应用"><a href="#五、AQS-AbstractQueuedSynchronizer-原理及应用" class="headerlink" title="五、AQS(AbstractQueuedSynchronizer)原理及应用"></a>五、AQS(AbstractQueuedSynchronizer)原理及应用</h2><h3 id="1-AQS原理"><a href="#1-AQS原理" class="headerlink" title="1. AQS原理"></a>1. AQS原理</h3><img src="/2020/02/09/java_concurrent/aqsuml.png" alt="aqs" style="zoom: 50%;">

<p>上面在讲ReentrantLock等的过程中说到它是基于AQS实现的。AQS提供了一个框架，该框架可用于实现基于FIFO队列的阻塞锁或相关同步器(semaphores, events, etc)。由于只是提供了一个框架，其子类需要提供具体实现，一般来说子类应该被定义为non-public的内部辅助类（例如ReentrantLock类内部的Sync类，如上面类图所示），用于实现其外部类的同步性质。AQS框架支持独占模式和共享模式，供具体实现来选择。下面列出其子类需要具体实现的方法列表。</p>
<table>
<thead>
<tr>
<th>需要子类实现的方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>tryAcquire</td>
<td>尝试在互斥模式下acquire</td>
</tr>
<tr>
<td>tryRelease</td>
<td>尝试在互斥模式下release</td>
</tr>
<tr>
<td>tryAcquireShared</td>
<td>尝试在共享模式下acquire</td>
</tr>
<tr>
<td>tryReleaseShared</td>
<td>尝试在共享模式下acquire</td>
</tr>
<tr>
<td>isHeldExclusively</td>
<td>判断是否被当前线程独占</td>
</tr>
</tbody></table>
<p>子类通过实现上面这些方法决定了同步器在获取同步时的行为。</p>
<p>下面来解释一下AQS的运行机制。</p>
<h4 id="1-1-Node类"><a href="#1-1-Node类" class="headerlink" title="1.1 Node类"></a>1.1 Node类</h4><p>从上面的类图可以看到AQS类内部有一个Node类，该类用于实现一个双向链表，表示等待获取的线程队列，该类有5个成员变量<br>| 变量               | 含义                   |<br>| —————– | ———————– |<br>| waitStatus        | 该节点的状态：CANCELLED(acquire取消，在锁的场景下可以理解为取消加锁), SIGNAL(等待唤醒), CONDITION(等待一个condition的唤醒), PROPAGATE(共享模式下), 0(初始状态) |<br>| thread            | 该等待节点对应的线程 |<br>| prev  | 等待队列的前一个节点 |<br>| next  | 等待队列的后一个节点 |<br>| nextWaiter | 若该节点在等待一个condition，则nextWaiter指向等待该condition的下一个节点 |</p>
<h4 id="1-2-ConditionObject类"><a href="#1-2-ConditionObject类" class="headerlink" title="1.2 ConditionObject类"></a>1.2 ConditionObject类</h4><p>ConditionObject类实现了Condition接口，Condition一般是配合Lock使用，这里ConditionObject用于配合AQS实现类似的效果，例如，可以创建多个ConditionObject类表示不同的条件，满足某一个条件则唤醒该ConditionObject对应的等待队列中的节点，并将其加入AQS的等待队列，去尝试获取锁。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>firstWaiter</td>
<td>该ConditionObject的等待队列的头节点</td>
</tr>
<tr>
<td>nextWaiter</td>
<td>该ConditionObject的等待队列的尾节点</td>
</tr>
</tbody></table>
<h4 id="1-3-AQS类"><a href="#1-3-AQS类" class="headerlink" title="1.3 AQS类"></a>1.3 AQS类</h4><p>有3个成员变量</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>state</td>
<td>保存状态的变量，在锁的场景下可以是锁的状态，如0表示未加锁，1表示加锁；或者可重入锁的情况下保存锁重入的次数，0表示未加锁，3表示已加锁并重入了3次</td>
</tr>
<tr>
<td>head</td>
<td>等待获取锁的队列的头节点</td>
</tr>
<tr>
<td>tail</td>
<td>等待获取锁的队列的尾节点</td>
</tr>
</tbody></table>
<p>通过上面对3个类以及AQS源码的分析，我们可以得出AQS的运行时数据结构，当尝试获取锁时，将对应线程加入等待队列，释放锁时，将其移出队列。若要支持Condition，则可以利用ConditionObject，ConditionObject实现了条件队列。</p>
<img src="/2020/02/09/java_concurrent/aqs.png" alt="aqs" style="zoom: 50%;">



<h4 id="1-4-基于AQS实现的锁及其他同步器"><a href="#1-4-基于AQS实现的锁及其他同步器" class="headerlink" title="1.4 基于AQS实现的锁及其他同步器"></a>1.4 基于AQS实现的锁及其他同步器</h4><p>基于AQS实现的锁及其他同步器如下：</p>
<table>
<thead>
<tr>
<th>使用了AQS的同步器实现</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>ReentrantLock</td>
<td>可重入锁，类似synchronized</td>
</tr>
<tr>
<td>ReentrantReadWriteLock</td>
<td>读写锁，适用于需要加锁的读多写少的场景</td>
</tr>
<tr>
<td>Semaphore</td>
<td>信号量，用于控制并发量</td>
</tr>
<tr>
<td>CountdownLatch</td>
<td>闭锁，让线程等待其他线程的完成</td>
</tr>
</tbody></table>
<h3 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h3><p>ReentrantLock的特性如下：</p>
<ul>
<li><p>可重入：同一个线程最大重入次数2147483647</p>
</li>
<li><p>支持公平锁与非公平锁：公平锁是指线程获取锁时要先判断当前排队的线程队列是否为空，为空则直接通过CAS机制尝试获取锁，不为空则排队；非公平锁是指线程获取锁时先尝试获取锁，失败则再次尝试获取锁（自旋），再次失败则进入排队队列，进入排队队列后，所有线程都排队，死循环至获取锁成功或中断。</p>
</li>
</ul>
<p>ReentrantLock是利用AQS实现的，具体的分析可以查看美团技术团队的这篇文章</p>
<p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html[^2]" target="_blank" rel="noopener">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html[^2]</a></p>
<p>非常详细，示意图清晰。</p>
<h2 id="六、多线程框架"><a href="#六、多线程框架" class="headerlink" title="六、多线程框架"></a>六、多线程框架</h2><h3 id="1-Executor框架-JAVA-5"><a href="#1-Executor框架-JAVA-5" class="headerlink" title="1. Executor框架(JAVA 5)"></a>1. Executor框架(JAVA 5)</h3><img src="/2020/02/09/java_concurrent/executor.png" alt="executor" style="zoom: 33%;">

<p>Executor接口提供了execute方法，该方法将任务提交，并在之后的某个时间点执行该任务，具体执行策略取决于其具体实现。ExecutorService在Executor的基础上提供了管理Executor生命周期的方法，如shutDown, shutDownNow方法。ThreadPoolExecutor是Executor的实现类，实现了基于线程池的Executor框架。</p>
<h4 id="1-1-线程池"><a href="#1-1-线程池" class="headerlink" title="1.1 线程池"></a>1.1 线程池</h4><p>Executors类提供了生成ThreadPoolExecutor，ScheduledThreadPoolExecutor，ForkJoinPool的工厂方法：</p>
<table>
<thead>
<tr>
<th>生成线程池方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool</td>
<td><code>new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</code></td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td><code>new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));</code></td>
</tr>
<tr>
<td>newCachedThreadPool</td>
<td><code>new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</code></td>
</tr>
<tr>
<td>newScheduledThreadPool</td>
<td><code>new ScheduledThreadPoolExecutor(corePoolSize);</code></td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td><code>new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));</code></td>
</tr>
<tr>
<td>newWorkStealingPool</td>
<td><code>new ForkJoinPool (Runtime.getRuntime().availableProcessors(),      ForkJoinPool.defaultForkJoinWorkerThreadFactory,      null, true);</code></td>
</tr>
</tbody></table>
<p>可以看到newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool方法返回的都是ThreadPoolExecutor对象，只不过配置不同；newScheduledThreadPool，newSingleThreadScheduledExecutor方法返回的都是ScheduledThreadPoolExecutor对象；newWorkStealingPool返回的是ForkJoinPool。</p>
<h4 id="1-2-线程池配置"><a href="#1-2-线程池配置" class="headerlink" title="1.2 线程池配置"></a>1.2 线程池配置</h4><h5 id="1-2-1-ThreadPoolExecutor"><a href="#1-2-1-ThreadPoolExecutor" class="headerlink" title="1.2.1 ThreadPoolExecutor"></a>1.2.1 ThreadPoolExecutor</h5><p>ForkJoinPool这个后面单独讲，先讲一下ThreadPoolExecutor，其构造函数即配置参数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>线程池中的最小线程数，线程池初始化后核心线程并不开始，除非调用了prestartAllCoreThreads</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>超过corePoolSize数量的线程的最长空闲时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务的排队队列：有限队列、无限队列、同步移交</td>
</tr>
<tr>
<td>threadFactory</td>
<td>创建线程的工厂方法，一般直接采用默认的Executors类提供的DefaultThreadFactory</td>
</tr>
<tr>
<td>handler</td>
<td>当线程池已满且队列已满时的任务提交时的处理策略，有CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy</td>
</tr>
</tbody></table>
<h5 id="1-2-2-最佳的线程池大小"><a href="#1-2-2-最佳的线程池大小" class="headerlink" title="1.2.2 最佳的线程池大小"></a>1.2.2 最佳的线程池大小</h5><p>首先，如果存在不同类型的任务，且差别很大，比如计算密集型和I/O密集型任务，那么最好使用多个线程池。</p>
<p>最佳线程池大小的配置可以根据任务的类型大致如下计算：</p>
<ul>
<li>计算密集型任务线程池大小：CPU个数+1</li>
<li>I/O密集型任务线程池大小：CPU个数 * CPU目标使用率 * （1+等待时间与计算时间的比）</li>
</ul>
<p>其他比如连接池大小、内存、文件句柄、套接字句柄等都会限制线程池大小</p>
<h4 id="1-3-Future-Callable"><a href="#1-3-Future-Callable" class="headerlink" title="1.3 Future, Callable"></a>1.3 Future, Callable</h4><p><img src="/2020/02/09/java_concurrent/future.png" alt="future"></p>
<p>Runnable提供了run方法用于执行计算，Callable的call方法可以返回计算的执行结果。</p>
<p>Future描述了任务的生命周期，提供了方法获取任务执行的结果，取消任务、检查任务是否完成或取消。ExecutorService的submit方法接受Runnable或Callable并返回一个Future。FutureTask是Future的具体实现。</p>
<h4 id="1-4-CompletionService及其实现ExecutorCompletionService"><a href="#1-4-CompletionService及其实现ExecutorCompletionService" class="headerlink" title="1.4 CompletionService及其实现ExecutorCompletionService"></a>1.4 CompletionService及其实现ExecutorCompletionService</h4><p>CompletionService整合了Executor和BlockingQueue的功能，ExecutorCompletionService是其具体实现。提交到ExecutorCompletionService的任务被包装为一个QueueingFuture，覆盖了done方法，该方法在任务完成时将结果放入其BlockingQueue中。</p>
<h4 id="1-5-线程取消、线程池关闭、JVM关闭"><a href="#1-5-线程取消、线程池关闭、JVM关闭" class="headerlink" title="1.5 线程取消、线程池关闭、JVM关闭"></a>1.5 线程取消、线程池关闭、JVM关闭</h4><h5 id="1-5-1-线程取消"><a href="#1-5-1-线程取消" class="headerlink" title="1.5.1 线程取消"></a>1.5.1 线程取消</h5><p>线程取消有以下方式：</p>
<ul>
<li>循环检查取消标志</li>
<li>中断：对于处于阻塞状态中的线程无法通过设置取消标志实现取消，中断机制提供了这种情况下的取消机制。每个线程有一个boolean类型的中断状态，中断时设置为true，即线程B调用线程A的interrupt方法时，线程A的中断状态被设置为true。阻塞库函数，例如，Thread.sleep或Object.wait通过native方法检测线程是否被中断，其对中断的响应表现为：清除中断状态并抛出异常InterruptedException，表示阻塞操作因中断提前结束</li>
<li>通过Future.cancel取消</li>
</ul>
<h5 id="1-5-2-线程异常处理"><a href="#1-5-2-线程异常处理" class="headerlink" title="1.5.2 线程异常处理"></a>1.5.2 线程异常处理</h5><ul>
<li>可以在线程内部catch异常</li>
<li>线程API提供了UncaughtExceptionHandler，当线程因为未捕获异常退出时，该handler处理异常，如果handler不存在，默认行为是像System.err打印stack trace</li>
<li>只有通过execute方法提交的任务才能将抛出的异常传给异常处理器，通过submit方法提交的任务，只会被Future.get方法重新抛出为ExecutionException</li>
</ul>
<h5 id="1-5-3-JVM的关闭"><a href="#1-5-3-JVM的关闭" class="headerlink" title="1.5.3 JVM的关闭"></a>1.5.3 JVM的关闭</h5><ul>
<li><p>Shutdown Hook</p>
<p>Shutdown Hook是通过Runtime.addShutdownHook方法注册的尚未开始的线程。如果是通过调用Runtime.halt或者kill -9的方式强行关闭JVM，那么除了关闭JVM之外不需要完成任何其他动作，也不会运行Shutdown Hook；</p>
<p>Shutdown Hook之间并发执行，不保证顺序，Shutdown Hook之行结束后，如果runFinalizersOnExit为true，JVM可以选择运行finalizer，之后停止；</p>
<p>JVM不会停止或者中断应用线程，应用线程在JVM停止时强制退出。</p>
</li>
<li><p>daemon线程</p>
<p>当只有daemon线程时，JVM会发起退出，daemon线程会被抛弃，不会执行finally块，也不会释放栈</p>
</li>
<li><p>Finalizer</p>
<p>参见我的文章《Object.finalize()方法与Finalizer类浅析》，推荐的操作是：不要使用Finalier</p>
</li>
</ul>
<h3 id="2-Fork-Join框架"><a href="#2-Fork-Join框架" class="headerlink" title="2. Fork/Join框架"></a>2. Fork/Join框架</h3><p>原本想在此针对Fork/Join框架写一小节的，由于源码阅读工作量较大，暂时搁置，以后再说。</p>
<h3 id="3-CompletableFuture-JAVA-8"><a href="#3-CompletableFuture-JAVA-8" class="headerlink" title="3. CompletableFuture(JAVA 8)"></a>3. CompletableFuture(JAVA 8)</h3><p>CompletableFuture相关可先参考以下文章：</p>
<p><a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">https://colobu.com/2016/02/29/Java-CompletableFuture/</a></p>
<p><a href="https://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html" target="_blank" rel="noopener">https://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html</a></p>
<h2 id="七、活跃性问题、性能问题"><a href="#七、活跃性问题、性能问题" class="headerlink" title="七、活跃性问题、性能问题"></a>七、活跃性问题、性能问题</h2><h3 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h3><p>死锁最常见的场景是出现了环路的锁依赖关系。在数据库系统中，一般设计了死锁监测，通过检查表示锁依赖关系的有向图上是否存在环路，如果存在死锁，会选择一个事务退出。</p>
<p>不光是锁的使用会造成死锁，资源的使用也可能造成死锁，例如有两个数据库D1、D2的连接池，线程A持有到数据库D1的连接，等待D2的连接，线程B持有到数据库D2的连接，等待D1的连接，这就有可能造成死锁，若连接池大小为1，则一定发生死锁。</p>
<p>通过使用显示Lock的tryLock方法的带有timeout的版本，能够一定程度上避免死锁，至少在死锁发生的情况下能够通过超时进行回退。</p>
<p>thread dump能够进行死锁检测，可用于线上诊断。</p>
<h3 id="2-饥饿"><a href="#2-饥饿" class="headerlink" title="2. 饥饿"></a>2. 饥饿</h3><p>饥饿问题是指当线程访问它需要的资源时被拒绝，不能继续进行，常见的是CPU资源的饥饿问题。线程优先级的使用不当、死循环都会造成CPU资源的饥饿问题</p>
<p>非公平锁也会造成线程的饥饿问题，特殊情况下，先尝试获取锁的线程反而没法抢到锁。</p>
<h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><ul>
<li><p>弱响应性问题：即响应时间较长</p>
</li>
<li><p>活锁：活锁问题一般发生在错误恢复机制中，例如，在消息处理应用程序中，如果对某种特定类型的消息处理存在bug，每次处理都会失败，失败后又被放回队首，下次还是处理这个消息，形成了死循环。可以通过在错误恢复机制中引入一定的随机性来避免着问题。</p>
</li>
</ul>
<h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h3><ul>
<li><p>线程上下文切换：包括线程调度的花费、线程换入后CPU缓存数据的加载都是线程上下文切换带来的花费。</p>
</li>
<li><p>内存同步：synchronized、volatile等提供的可见性保证是通过使用内存屏障使CPU缓存无效化实现的，不能使用CPU缓存使得性能下降，并且内存屏障还能防止指令重排序，这就导致了编译器不能对代码执行进行优化。</p>
<p>现在JVM中的JIT编译器通过逃逸分析能够实现锁消除的优化，如果一个变量不从线程内逸出，对其的加锁操作会被省略，或者通过锁粗化，即将邻近的synchronized块用相同的锁合并起来。这些JVM的优化机制表明对于没有竞争的同步代码，其开销已经经过很好的优化了，真正影响性能的是真正发生了锁竞争的代码。</p>
</li>
<li><p>阻塞</p>
<p>获取锁的时候如果存在竞争会发生阻塞，这时候可以选择自旋或者线程挂起，取决于具体的场景。</p>
</li>
<li><p>如何减少锁的竞争</p>
<ul>
<li>缩小锁的范围：避免很大的同步块</li>
<li>减小锁的粒度：通过锁的分拆或分离，将一个粗粒度的锁拆分为多个锁，例如ConcurrentHashMap相比HashTable通过更细粒度的锁提升了性能</li>
<li>使用非独占锁：读写锁相比独占锁带来了性能提升</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/01/05/java_finalize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/java_finalize/" class="post-title-link" itemprop="url">Object.finalize()方法与Finalizer类浅析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 22:09:18 / 修改时间：22:08:58" itemprop="dateCreated datePublished" datetime="2020-01-05T22:09:18+08:00">2020-01-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Object-finalize-方法与Finalizer类浅析"><a href="#Object-finalize-方法与Finalizer类浅析" class="headerlink" title="Object.finalize()方法与Finalizer类浅析"></a>Object.finalize()方法与Finalizer类浅析</h1><p>这部分内容属于GC相关的内容，可以参考 <a href="https://www.jianshu.com/p/9d2788fffd5f" target="_blank" rel="noopener">https://www.jianshu.com/p/9d2788fffd5f</a> <a href="https://www.jianshu.com/p/9d2788fffd5f" target="_blank" rel="noopener">^2</a>，此文写的比较深入，涉及到了hotspot的源码，强烈推荐。</p>
<h2 id="一、finalize-1"><a href="#一、finalize-1" class="headerlink" title="一、finalize()^1"></a>一、finalize()<a href="https://www.cnblogs.com/benwu/articles/5812903.html" target="_blank" rel="noopener">^1</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizerDemo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> AtomicInteger aliveCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    FinalizerDemo() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        aliveCount.incrementAndGet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        FinalizerDemo.aliveCount.decrementAndGet();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            FinalizerDemo f = <span class="keyword">new</span> FinalizerDemo();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((i % <span class="number">100_000</span>) == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                System.out.format(<span class="string">"After creating %d objects, %d are still alive.%n"</span>, <span class="keyword">new</span> Object[]&#123;i, FinalizerDemo.aliveCount.get()&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>运行这段代码，加上-XX:+PrintGCDetails参数查看GC详情，可以发现很快就开始full gc，而去掉对finalize()方法的重写则不会触发full gc。这是为什么呢？这就涉及到重写了finalize()方法的类的回收了，下面详细说一下，或者也可以直接阅读上面推荐的文章。</p>
<p>列一下finalize()方法相关的特性：</p>
<ul>
<li>当GC判断没有其他对该对象的引用时，会调用该方法，一般用于执行资源释放或其他清理工作</li>
<li>finalize()方法抛出的异常会被忽略</li>
<li>finalize()方法中可以使该对象重新关联到引用链上，也即是“复活”该对象，例如，让一个静态全局变量指向该对象，使其免于被回收</li>
<li>finalize()方法最多执行一次</li>
</ul>
<h2 id="二、Finalizer"><a href="#二、Finalizer" class="headerlink" title="二、Finalizer"></a>二、Finalizer</h2><p>阅读上面推荐的文章就知道finalize()方法与Finalizer类脱不开关系。下面分析一下这个类的源码。</p>
<p>Finalizer类有3个静态变量，2个成员变量，分别是：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ReferenceQueue<Object> queue</Object></td>
<td>全局静态变量，是一个引用队列，保存Finalizer对象</td>
</tr>
<tr>
<td>Finalizer unfinalized</td>
<td>全局静态变量，Finalizer对象以双向链表的形式保存，该变量指向当前链表的头部，每次新创建一个Finalizer对象会将其放在链表头部</td>
</tr>
<tr>
<td>Object lock</td>
<td>全局静态变量，用于在对双向链表操作时加锁</td>
</tr>
<tr>
<td>next</td>
<td>链表中当前对象的下一个</td>
</tr>
<tr>
<td>prev</td>
<td>链表中当前对象的前一个</td>
</tr>
</tbody></table>
<p>注意到Finalizer类的源码中有一个register方法，注释是该方法由VM调用，推测是当重写了finalize()的对象初始化时会调用register方法（推荐文章中有对这部分的hotspot源码分析），该方法会将该对象作为构造器参数创建一个Finalizer对象，Finalizer继承了FinalReference<Object>，因此构造器会将finalizee（即实现了finalize()方法的对象）和全局的ReferenceQueue作为构造参数构造Reference<Object>。</Object></Object></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Finalizer</span><span class="params">(Object finalizee)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">super</span>(finalizee, queue);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    add();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoked by VM */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object finalizee)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">new</span> Finalizer(finalizee);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Finalizer类的runFinalizer方法就是最终用来调用对象的finalize()方法的。先判断是否已执行过finalize()方法，若没有，则从双向链表中移除自身，然后调用finalizee的finalize()方法，最后finalizee = null;这一步注释说的是清理包含这个变量的栈帧，减少false retention概率，关于false retention后面单开文章说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (hasBeenFinalized()) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            remove();<span class="comment">//不去掉的话，会导致对象仍然在引用链上，无法回收</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            Object finalizee = <span class="keyword">this</span>.get();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (finalizee != <span class="keyword">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                jla.invokeFinalize(finalizee);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* Clear stack slot containing this variable, to decrease</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                   the chances of false retention with a conservative GC */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                finalizee = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>.clear();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<h3 id="FinalizerThread"><a href="#FinalizerThread" class="headerlink" title="FinalizerThread"></a>FinalizerThread</h3><p>Finalizer类通过静态初始化代码块启动一个FinalizerThread守护线程，该线程优先级较低。注意线程优先级较低这一点，正是这一点导致在上面的示例中来不及执行对象的finalize()方法，导致垃圾回收很慢，内存泄漏，触发full gc，甚至OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">         tgn != <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">         tg = tgn, tgn = tg.getParent());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    Thread finalizer = <span class="keyword">new</span> FinalizerThread(tg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    finalizer.setDaemon(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    finalizer.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面看下FinalizerThread的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    FinalizerThread(ThreadGroup g) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">super</span>(g, <span class="string">"Finalizer"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (running)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Finalizer thread starts before System.initializeSystemClass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// is called.  Wait until JavaLangAccess is available</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!VM.isBooted()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// delay until VM completes initialization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                VM.awaitBooted();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// ignore and continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        running = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (;;) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                Finalizer f = (Finalizer)queue.remove();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                f.runFinalizer(jla);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="comment">// ignore and continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>主要关注最后的死循环部分，调用queue的remove()方法，取出队列中的Finalizer对象，执行其runFinalizer方法。</p>
<p>到这里就剩下一个疑问点，Finalizer对象是什么时候加入queue队列的？这就要说到Reference<T>类了。</T></p>
<h2 id="三、Reference"><a href="#三、Reference" class="headerlink" title="三、Reference"></a>三、Reference</h2><p>前面说到Finalizer继承了FinalReference<Object>，而FinalReference类继承了Reference。看一下这个类的静态初始化代码块，里面启动了一个ReferenceHandler守护线程，该线程优先级较高。</Object></p>
<h3 id="ReferenceHandler"><a href="#ReferenceHandler" class="headerlink" title="ReferenceHandler"></a>ReferenceHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">         tgn != <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">         tg = tgn, tgn = tg.getParent());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* If there were a special system-only priority greater than</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * MAX_PRIORITY, it would be used here</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    handler.setDaemon(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    handler.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// provide access in SharedSecrets</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryHandlePendingReference</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> tryHandlePending(<span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>ReferenceHandle线程死循环执行一个方法tryHandlePending，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        Reference&lt;Object&gt; r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        Cleaner c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                    r = pending;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 'instanceof' might throw OutOfMemoryError sometimes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// so do this before un-linking 'r' from the 'pending' chain...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                    c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// unlink 'r' from 'pending' chain</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                    pending = r.discovered;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                    r.discovered = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// because it may try to allocate exception objects.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (waitForNotify) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                        lock.wait();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// retry if waited</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">return</span> waitForNotify;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Give other threads CPU time so they hopefully drop some live references</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// and GC reclaims some space.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// Also prevent CPU intensive spinning in case 'r instanceof Cleaner' above</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// persistently throws OOME for some time...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            Thread.yield();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// retry</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// retry</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Fast path for cleaners</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            c.clean();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<p>主要逻辑就是将pending链表的头节点取出，并将其加入队列中（最后3行代码），其中pending链表是GC扫描出的pending状态的Reference对象链表，Finalizer实现了Reference，也会被扫描出来，至于具体逻辑就要查看jdk源码了，这个正好在参考文献【2】也就是最开头推荐的文章中有提到。</p>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>回到最开始的例子，再分析一下。main函数死循环创建一个重写了finalize()方法的对象，JVM会为每一个对象创建一个Finalizer对象，ReferenceHandle线程负责将Finalizer对象加入ReferenceQueue，该线程优先级较高，而FinalizerThread线程负责消费ReferenceQueue，执行对象的finalize()方法，优先级较低。只有当对象的finalize()方法执行完，对象才能被回收。</p>
<p>那么当FinalizerThread线程由于优先级低而抢不到CPU资源，或者finalize()方法执行较慢等原因来不及消费ReferenceQueue时，就会出现GC无法回收垃圾，从而导致full gc。</p>
<p>finalize()方法最多执行一次的原理也在此说一下我个人的理解，不一定正确。上面说到，当对象创建时，如果该对象重写了finalize()方法，JVM会调用Finalizer对象的register方法，即该对象对应的Finalizer对象只会被创建一次，而一旦这个Finalizer对象被移出ReferenceQueue就不会再回到ReferenceQueue。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/01/04/spring_start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/spring_start/" class="post-title-link" itemprop="url">Spring Boot/Spring的启动过程分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-04 21:01:19 / 修改时间：22:55:14" itemprop="dateCreated datePublished" datetime="2020-01-04T21:01:19+08:00">2020-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Spring-Boot-Spring的启动过程分析"><a href="#Spring-Boot-Spring的启动过程分析" class="headerlink" title="Spring Boot/Spring的启动过程分析"></a>Spring Boot/Spring的启动过程分析</h1><h2 id="一、Spring-Boot启动"><a href="#一、Spring-Boot启动" class="headerlink" title="一、Spring Boot启动"></a>一、Spring Boot启动</h2><p>先来一段众所周知的spring boot的启动入口代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>里面的核心代码如下，各步骤已添加注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * Run the Spring application, creating and refreshing a new</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">		stopWatch.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">		configureHeadlessProperty();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">		* 获取META-INF/spring.factories中配置的SpringApplicationRunListener类型的监听器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">		* 默认只有一个listener是org.springframework.boot.context.event.EventPublishingRunListener</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//EventPublishingRunListener发布ApplicationStartingEvent事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		listeners.starting();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">			<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			* 创建并配置Environment（主要是PropertySource和Profile）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			*之后调用监听器的environmentPrepared方法，触发EventPublishingRunListener发布ApplicationEnvironmentPreparedEvent事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			* 将Environment与Application绑定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//设置spring.beaninfo.ignore系统属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">			configureIgnoreBeanInfo(environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//打印banner</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">			Banner printedBanner = printBanner(environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 根据应用类型创建ApplicationContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 例如web应用创建的是AnnotationConfigServletWebServerApplicationContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      **/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">			context = createApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//获取配置的异常上报类，用于后续异常上报</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">					new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * prepareContext内部逻辑：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 1. postProcessApplicationContext：配置bean工厂的beanNameGenerator，ConversionService及context的resourceLoader</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 2. applyInitializers使用META-INF/spring.factories中配置的ApplicationContextInitializer初始化ApplicationContext，默认配了7个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 3. 调用监听器的contextPrepared方法，触发EventPublishingRunListener发布ApplicationContextInitializedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 4. 获取beanFactory并配置（默认是DefaultListableBeanFactory，此时已有几个spring内部的bean已注册），如注册springApplicationArguments单例类，设置allowBeanDefinitionOverriding参数等，配置懒加载LazyInitializationBeanFactoryPostProcessor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 5. 加载bean，看源码是支持xml读取，annotation扫描，甚至groovy，实际上只加载了入口类也就是上面的Application类，将其注册为单例并获取了其注解原数据，即<span class="doctag">@SpringBootApplication</span>注解</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 6. 调用监听器的contextLoaded方法，触发EventPublishingRunListener发布ApplicationPreparedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      **/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">			prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">			<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			* 调用AbstractApplicationContext的refresh方法，然后注册shutdownhook，这一步核心其实就是spring的启动了，这个在第3节展开</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">      refreshContext(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">			afterRefresh(context, applicationArguments);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">			stopWatch.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//调用监听器的started方法，触发EventPublishingRunListener发布ApplicationStartedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">			listeners.started(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//调用ApplicationRunner，然后调用CommandLineRunner</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">			callRunners(context, applicationArguments);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//里面有一步是：调用监听器的failed方法，触发EventPublishingRunListener发布ApplicationFailedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//调用监听器的running方法，触发EventPublishingRunListener发布ApplicationReadyEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">			listeners.running(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> context;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr></table></figure>
<p>可以看到spring boot的启动是在spring启动的基础上增加了一些特性，例如根据应用类型推断并指定ApplicationContext的具体实现，各阶段事件的发布（提供了一个扩展点），调用ApplicationRunner，CommandLineRunner（又一个扩展点）等。下面来一张详细的流程图，个人觉得这个图画的很好<a href="https://www.cnblogs.com/l3306/p/10752907.html" target="_blank" rel="noopener">^1</a>，可以参考该图一步步看源码。</p>
<p><strong>PS：推荐先粗读一遍源码，然后对应用进行debug，一步步看执行逻辑以及每个步骤执行完毕后的数据以及状态，可以对细节有更好的理解。例如，有些变量是在构造器初始化时加载的配置，这个光看源码很难看到。</strong></p>
<p><img src="/2020/01/04/spring_start/1158841-20190707171658626-1389392187.png" alt="img"></p>
<h2 id="二、Spring-Boot自动化配置"><a href="#二、Spring-Boot自动化配置" class="headerlink" title="二、Spring Boot自动化配置"></a>二、Spring Boot自动化配置</h2><h3 id="1-EnableAutoConfiguration"><a href="#1-EnableAutoConfiguration" class="headerlink" title="1. @EnableAutoConfiguration"></a>1. @EnableAutoConfiguration</h3><p><img src="/2020/01/04/spring_start/1650e0e47481e59a.png" alt="img"></p>
<p>spring boot提供了自动配置，@SpringBootApplication注解中的@EnableAutoConfiguration注解是spring boot自动配置的关键，原理可阅读文章【2】<a href="https://juejin.im/post/5b679fbc5188251aad213110" target="_blank" rel="noopener">^2</a>，以后有机会再展开详细描述。</p>
<h3 id="2-META-INF-spring-factories"><a href="#2-META-INF-spring-factories" class="headerlink" title="2. META-INF/spring.factories"></a>2. META-INF/spring.factories</h3><p>上面说到@EnableAutoConfiguration注解通过读取META-INF/spring.factories配置文件实现自动配置，这里说一下META-INF/spring.factories配置文件。</p>
<ol>
<li>配置是K/V对，key是接口的全限定名，value是该接口的实现类的名字，可以是逗号分隔的多个值，示例如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">example.MyService&#x3D;example.MyServiceImpl1,example.MyServiceImpl2</span></pre></td></tr></table></figure>

<ol start="2">
<li><p>META-INF/spring.factories配置文件可在多个jar中配置，基于这个我们可以实现自己的自动配置类，并将其配置在自己的jar的META-INF/spring.factories配置文件中，spring boot会帮我们完成自动配置。</p>
</li>
<li><p>spring boot自带的META-INF/spring.factories配置文件里已经配置了许多这样的配置项。</p>
</li>
<li><p>借助spring框架的SpringFactoriesLoader可以加载META-INF/spring.factories配置文件，SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置。</p>
</li>
</ol>
<p><strong>是不是有点像java的SPI加载机制</strong></p>
<h2 id="三、Spring的启动"><a href="#三、Spring的启动" class="headerlink" title="三、Spring的启动"></a>三、Spring的启动</h2><p>上面提到调用了AbstractApplicationContext的refresh()方法，其实就是spring启动时执行的方法，里面的执行顺序是固定的。</p>
<h3 id="1-AbstractApplicationContext的refresh-方法"><a href="#1-AbstractApplicationContext的refresh-方法" class="headerlink" title="1. AbstractApplicationContext的refresh()方法"></a>1. AbstractApplicationContext的refresh()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      prepareRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     	<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	* obtainFreshBeanFactory()方法内部调用refreshBeanFactory()，其默认实现由AbstractRefreshableApplicationContext提供，逻辑是：销毁原来的bean，关闭原来的bean factory，创建新的DefaultListableBeanFactory，调用loadBeanDefinitions()方法加载bean，这部分在后面详细展开；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	不过在spring boot的情况下这里的实现是AnnotationConfigServletWebServerApplicationContext类，并不会销毁原来的bean以及bean factory。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">     	<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	* 摘自该方法的注释，主要是配置bean factory</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    	* Configure the factory's standard context characteristics,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 		* such as the context's ClassLoader and post-processors.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 		**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      prepareBeanFactory(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">       	 <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">       	 * 摘自该方法的注释，主要是注册BeanPostProcessors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * Modify the application context's internal bean factory after its standard</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * initialization. All bean definitions will have been loaded, but no beans</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * will have been instantiated yet. This allows for registering special</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">         postProcessBeanFactory(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 这一步会调用BeanFactoryPostProcessor，其中有一个是ConfigurationClassPostProcessor，扫描@Configuration注解标注的类，并完成相应的bean definition的注册</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">         registerBeanPostProcessors(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Initialize message source for this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">         initMessageSource();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">         initApplicationEventMulticaster();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">       	 <span class="comment">// web应用的情况下会检查是否有WebServer，若没有则新建一个WebServer，spring boot默认是tomcat</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">         onRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 注册ApplicationListener类型的bean，并将之前发过的ApplicationEvent再发一遍</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">         registerListeners();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 完成bean factory的初始化，并将剩余的未实例化的单例bean实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">         finishBeanFactoryInitialization(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * Finish the refresh of this context, invoking the LifecycleProcessor's</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * onRefresh() method and publishing the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * &#123;@link org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">         finishRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">         destroyBeans();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Reset 'active' flag.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">         cancelRefresh(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Propagate exception to caller.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">         <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">         resetCommonCaches();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这块每一步的逻辑都相当复杂，涉及spring bean容器的很多特性以及扩展点，这些都需要具体去了解，后续再补上每一步的详情，先mark一下。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文基于spring-boot:2.2.1.RELEASE版本，只是粗略过了一遍启动流程，有些部分可能理解有误，内部细节还有待继续研究。另外不得不说，看spring源码是真的累。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/01/04/tomcat_spring_web_application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/tomcat_spring_web_application/" class="post-title-link" itemprop="url">Tomcat中部署spring web application</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-04 21:01:19 / 修改时间：21:23:12" itemprop="dateCreated datePublished" datetime="2020-01-04T21:01:19+08:00">2020-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Tomcat中部署spring-web-application"><a href="#Tomcat中部署spring-web-application" class="headerlink" title="Tomcat中部署spring web application"></a>Tomcat中部署spring web application</h1><h2 id="一、Servlet容器"><a href="#一、Servlet容器" class="headerlink" title="一、Servlet容器"></a>一、Servlet容器</h2><p>java的web应用是基于Servlet的，Tomcat是比较有名的Servlet容器，一个Tomcat中可以部署多个Servlet。下图是Tomcat的容器模型。</p>
<p><img src="/2020/01/04/tomcat_spring_web_application/image002.jpg" alt="图 1 . Tomcat 容器模型"></p>
<p>有关Servlet与Tomcat的原理推荐阅读下面几篇文章进行了解：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/</a></p>
<p><a href="http://objcoding.com/2019/05/30/tomcat-architecture/" target="_blank" rel="noopener">http://objcoding.com/2019/05/30/tomcat-architecture/</a></p>
<h3 id="1-Tomcat中war的部署"><a href="#1-Tomcat中war的部署" class="headerlink" title="1. Tomcat中war的部署"></a>1. Tomcat中war的部署</h3><p>web应用以war包的形式部署在Tomcat中，web.xml是web应用的部署配置文件，下面说说其中的一些配置元素。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>servlet</td>
<td>指定servlet</td>
</tr>
<tr>
<td>servlet-mapping</td>
<td>指定servlet与url之间的映射关系</td>
</tr>
<tr>
<td>filter</td>
<td>指定filter</td>
</tr>
<tr>
<td>filter-mapping</td>
<td>指定filter与url之间的映射关系</td>
</tr>
<tr>
<td>listener</td>
<td>指定监听器监听servlet上下文事件</td>
</tr>
<tr>
<td>context-param</td>
<td>servlet上下文初始化参数</td>
</tr>
<tr>
<td>welcome-file-list</td>
<td>一般用于指定欢迎页，如index.jsp</td>
</tr>
</tbody></table>
<p>以上是对servlet容器的简单介绍，以及在Tomcat中以war部署web应用时，web.xml的作用。</p>
<h2 id="二、Tomcat中启动spring"><a href="#二、Tomcat中启动spring" class="headerlink" title="二、Tomcat中启动spring"></a>二、Tomcat中启动spring</h2><p>在Tomcat中启动spring也就意味着如何启动并初始化spring上下文，在web应用中该上下文就是WebApplicationContext。</p>
<h3 id="1-ContextLoadListener"><a href="#1-ContextLoadListener" class="headerlink" title="1. ContextLoadListener"></a>1. ContextLoadListener</h3><p>WebApplicationContext可以通过在web.xml中配置ContextLoadListener这个listener实现初始化。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span></pre></td></tr></table></figure>

<p>ContextLoaderListener实现了ServletContextListener，该接口定义了两个方法可监听servlet的初始化与销毁，该接口的实现类也就是ContextLoaderListener有3种方式可接收到这两个通知事件：</p>
<ol>
<li><p>定义在web.xml配置文件中，也就是本文描述的方式；</p>
</li>
<li><p>加上javax.servlet.annotation.WebListener注解；</p>
</li>
<li><p>通过ServletContext的addListener方法添加；</p>
</li>
</ol>
<p>ContextLoaderListener在配置时需要注意：如果使用了org.springframework.web.util.Log4jConfigListener，需要在web.xml中将该listener配置在其之后。Log4jConfigListener用于初始化定制化的log4j。</p>
<h3 id="2-WebApplicationContext的创建"><a href="#2-WebApplicationContext的创建" class="headerlink" title="2. WebApplicationContext的创建"></a>2. WebApplicationContext的创建</h3><p>ContextLoaderListener将具体的创建WebApplicationContext的操作委派给ContextLoader执行，其关键方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span></span></span></pre></td></tr></table></figure>

<p>initWebApplicationContext先创建一个WebApplicationContext，然后完成配置并调用refresh()方法。</p>
<ol>
<li><p>WebApplicationContext的默认实现是XmlWebApplicationContext（配置在spring-web包中的ContextLoader.properties文件中），可以通过指定contextClass参数指定WebApplicationContext的实现，当然一般不会这么做。</p>
</li>
<li><p>WebApplicationContext初始化的配置文件地址可以通过在web.xml文件中的context-param配置节中配置contextConfigLocation参数指定，如：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">			classpath*:config/spring/local/appcontext-*.xml,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">			classpath*:config/spring/appcontext-*.xml</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span></pre></td></tr></table></figure>
<p>​        PS:存在多个配置文件地址的情况下，后面文件中定义的的bean definition会覆盖前面的。</p>
<p>还有一些其他的可配置参数可以影响WebApplicationContext的创建，这里没有全部列出，这些一般也是非常用的功能。</p>
<ol start="3">
<li>调用refresh()方法实际上是调用了AbstractApplicationContext的refresh()方法，里面就是标准的spring的ApplicationContext的启动流程，主要是BeanFactory的初始化以及相应的bean的加载与初始化，具体可参考我的另一篇文章《Spring Boot/Spring的启动过程分析》。</li>
</ol>
<h3 id="3-DispatchServlet"><a href="#3-DispatchServlet" class="headerlink" title="3. DispatchServlet"></a>3. DispatchServlet</h3><p>DispatchServlet是将HTTP请求分发至handlers或者controllers的中央分发器，提供了便利的映射和异常处理功能。下面列一下它的一些特性：</p>
<ol>
<li>一个web应用可以配置多个DispatcherServlet，每个DispatcherServlet在自己的命名空间内运行，加载自己私有的包含了mapping的应用上下文。只有通过ContextLoaderListener加载的上下文是共享的。</li>
<li>通过HandlerMapping的实现类来实现请求request到相应的handler的映射，可覆盖默认实现，默认实现是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span></pre></td></tr></table></figure></li>
<li>HandlerAdapter接口，用来适配请求和handler，可覆盖默认实现，默认实现是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter对应org.springframework.web.HttpRequestHandler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter对应org.springframework.web.servlet.mvc.Controller</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">另外还有一个默认的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span></pre></td></tr></table></figure></li>
<li>HandlerExceptionResolver负责dispatcher的异常处理策略，例如，发生某些特定异常时映射到某个错误页面。<br>这里只列出一些基础的，还有一些关于ViewResolver，MultipartResolver，LocaleResolver，ThemeResolver的没有列出，感兴趣的可以研究一下。</li>
</ol>
<h4 id="DispatchServlet的创建"><a href="#DispatchServlet的创建" class="headerlink" title="DispatchServlet的创建"></a>DispatchServlet的创建</h4><p>DispatchServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet。<br>servlet容器启动的时候会调用HttpServlet的init()方法，也就是说会调用HttpServletBean的init()方法，其中会调用FrameworkServlet的initServletBean()方法，其中会调用它的initWebApplicationContext()方法，创建这个DispatchServlet的ApplicationContext，并且会将ContextLoaderListener加载的ApplicationContext作为其parent。</p>
<p>那么如何才能让servlet容器去创建一个DispatchServlet呢？答案就是在web.xml中进行配置，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &lt;init-param&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            &lt;param-value&gt;classpath:config&#x2F;spring.mvc&#x2F;appcontext-servlet.xml&lt;&#x2F;param-value&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &lt;&#x2F;init-param&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &lt;&#x2F;servlet&gt;</span></pre></td></tr></table></figure>
<p>其中<code>contextConfigLocation</code>参数指定这个DispatcherServlet的ApplicationContext的配置，<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>表示在容器启动时就加载。</p>
<p>好了，再往下就是spring mvc的内容了，还有待研究。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文基于对spring 3.2.5版本的源码阅读，目前spring最新版本已到5.2.x，内容上可能有些过时，但理论上不影响对spring框架的理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/01/01/java_lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/java_lambda/" class="post-title-link" itemprop="url">Java 函数式编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-01 22:15:07 / 修改时间：23:56:25" itemprop="dateCreated datePublished" datetime="2020-01-01T22:15:07+08:00">2020-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Java-函数式编程"><a href="#Java-函数式编程" class="headerlink" title="Java 函数式编程"></a>Java 函数式编程</h1><h2 id="一、函数式接口"><a href="#一、函数式接口" class="headerlink" title="一、函数式接口"></a>一、函数式接口</h2><h3 id="1-FunctionalInterface注解"><a href="#1-FunctionalInterface注解" class="headerlink" title="1. @FunctionalInterface注解"></a>1. @FunctionalInterface注解</h3><p>@FunctionalInterface注解：作用于接口，表示该接口是函数式接口（functional interface）。</p>
<p>函数式接口有以下几个特点：</p>
<ol>
<li><p>函数式接口有且只有一个抽象方法</p>
</li>
<li><p>默认方法不计入抽象方法的个数，静态方法也不计入抽象方法个数</p>
</li>
<li><p>覆盖java.lang.Object的方法的方法也不计入抽象方法的个数</p>
</li>
<li><p>函数式接口可以通过lambda表达式、方法引用、构造器引用来创建实例</p>
</li>
<li><p>对于编译器来说，只要一个接口符合函数式接口的定义就会将其当作函数式接口，不一定需要@FunctionalInterface注解标注，注解用于检查该接口是否只包含一个抽象方法</p>
</li>
</ol>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloFuncInterface</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-JDK中的函数式接口"><a href="#2-JDK中的函数式接口" class="headerlink" title="2. JDK中的函数式接口"></a>2. JDK中的函数式接口</h3><p>java.lang.Runnable</p>
<p>java.awt.event.ActionListener</p>
<p>java.util.Comparator</p>
<p>java.util.concurrent.Callable</p>
<p>java.util.function包下的接口，如Consumer、Predicate、Supplier等</p>
<h2 id="二、lambda表达式"><a href="#二、lambda表达式" class="headerlink" title="二、lambda表达式"></a>二、lambda表达式</h2><p>lambda表达式用来实现函数式接口。</p>
<h3 id="1-lambda表达式形式"><a href="#1-lambda表达式形式" class="headerlink" title="1. lambda表达式形式"></a>1. lambda表达式形式</h3><p><code>(params) -&gt; expression</code><br><code>(params) -&gt; statement</code><br><code>(params) -&gt; { statements }</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 通过lambda表达式实现自定义的函数式接口(注：JAVA 8 之前一般是用匿名类实现的)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    HelloFuncInterface helloFuncInterface = () -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"hello"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    helloFuncInterface.hello();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-lambda表达式替换匿名类，减少冗余代码"><a href="#2-lambda表达式替换匿名类，减少冗余代码" class="headerlink" title="2. lambda表达式替换匿名类，减少冗余代码"></a>2. lambda表达式替换匿名类，减少冗余代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":runnable by lambda expression"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;).start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":runnable by anonymous class"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;).start();</span></pre></td></tr></table></figure>



<h2 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h2><p>方法引用由::双冒号操作符标示，看起来像C++的作用域解析运算符。<strong>实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！至于返回值就不作要求</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 方法引用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodReference</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    List&lt;String&gt; pets = Arrays.asList(<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"snake"</span>, <span class="string">"squirrel"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    pets.forEach((a) -&gt; System.out.println(a));<span class="comment">//lambda表达式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    pets.forEach(System.out::println);<span class="comment">//方法引用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="1-引用方法-1"><a href="#1-引用方法-1" class="headerlink" title="1. 引用方法^1"></a>1. 引用方法<a href="https://blog.csdn.net/TimHeath/article/details/71194938" target="_blank" rel="noopener">^1</a></h3><ul>
<li>对象引用::实例方法名</li>
</ul>
<p>System.out是一个静态成员变量对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">consumer.accept(<span class="string">"hello"</span>);</span></pre></td></tr></table></figure>

<ul>
<li>类名::静态方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Function&lt;Long, Long&gt; abs = Math::abs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">System.out.println(abs.apply(-<span class="number">3L</span>));</span></pre></td></tr></table></figure>

<ul>
<li>类名::实例方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; b = String::equals;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">System.out.println(b.test(<span class="string">"abc"</span>, <span class="string">"abcd"</span>));</span></pre></td></tr></table></figure>

<h3 id="2-引用构造器"><a href="#2-引用构造器" class="headerlink" title="2. 引用构造器"></a>2. 引用构造器</h3><p>在引用构造器的时候，构造器参数列表要与接口中抽象方法的参数列表一致,格式为 类名::new。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, StringBuffer&gt; fun = StringBuffer::<span class="keyword">new</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = fun.apply(<span class="number">10</span>);</span></pre></td></tr></table></figure>
<p>Function接口的apply方法接收一个参数，并且有返回值。在这里接收的参数是Integer类型，与StringBuffer类的一个构造方法StringBuffer(int capacity)对应，而返回值就是StringBuffer类型。上面这段代码的功能就是创建一个Function实例，并把它apply方法实现为创建一个指定初始大小的StringBuffer对象。</p>
<h3 id="3-引用数组"><a href="#3-引用数组" class="headerlink" title="3. 引用数组"></a>3. 引用数组</h3><p>引用数组和引用构造器很像，格式为 类型[]::new，其中类型可以为基本类型也可以是类。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer[]&gt; fun2 = Integer[]::<span class="keyword">new</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Integer[] arr2 = fun2.apply(<span class="number">10</span>);</span></pre></td></tr></table></figure>

<h2 id="四、java-util-function"><a href="#四、java-util-function" class="headerlink" title="四、java.util.function"></a>四、java.util.function</h2><h3 id="1-Predicate接口"><a href="#1-Predicate接口" class="headerlink" title="1. Predicate接口"></a>1. Predicate接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Predicate是一个函数式接口，也是一个泛型接口，作用是对传入的一个泛型参数进行判断，并返回一个boolean值，任何符合这一条件的lambda表达式都可以转为Predicate接口，该接口的实现一般用于集合过滤等。下面提供一些例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * lambda表达式加Predicate接口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">predicateDemo</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    List&lt;String&gt; pets = Arrays.asList(<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"snake"</span>, <span class="string">"squirrel"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//简单的Predicate接口示例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(s -&gt; s.startsWith(<span class="string">"s"</span>)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    Predicate&lt;String&gt; startWith = s -&gt; s.startsWith(<span class="string">"s"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    Predicate&lt;String&gt; lengthPredicate = s -&gt; s.length() &gt; <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate支持and()操作将两个Predicate接口的逻辑取与</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate and() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(startWith.and(lengthPredicate)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate支持or()操作将两个Predicate接口的逻辑取或</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate or() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(startWith.or(lengthPredicate)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate支持negate()操作将Predicate接口的逻辑取反</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate negate() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(startWith.negate()).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate静态方法isEqual()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate isEqual() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(Predicate.isEqual(<span class="string">"cat"</span>)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从示例中可以看到，Predicate接口支持and(), or(), negate()等，并且有一个静态方法isEqual。</p>
<h3 id="2-Consumer接口"><a href="#2-Consumer接口" class="headerlink" title="2. Consumer接口"></a>2. Consumer接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        Objects.requireNonNull(after);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Consumer是一个函数式接口，也是一个泛型接口，作用是对传入的一个泛型参数进行操作，可能会对原数据产生side effect，即改变数据。常见的例子有：</p>
<ol>
<li>Iterable接口的forEach方法接受一个Comsumer接口类型的操作，对集合中的元素进行操作，例如打印等。</li>
</ol>
<h3 id="3-Function接口"><a href="#3-Function接口" class="headerlink" title="3. Function接口"></a>3. Function接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该接口代表接受一个参数并返回一个参数的操作类型。</p>
<h3 id="4-Supplier接口"><a href="#4-Supplier接口" class="headerlink" title="4. Supplier接口"></a>4. Supplier接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Gets a result.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该接口表示调用后返回一个参数的操作类型，返回结果不要求一定是新创建的或者不同的。</p>
<h2 id="五、StreamAPI原理"><a href="#五、StreamAPI原理" class="headerlink" title="五、StreamAPI原理"></a>五、StreamAPI原理</h2><h3 id="1-Collection接口的stream-parallelStream-方法"><a href="#1-Collection接口的stream-parallelStream-方法" class="headerlink" title="1. Collection接口的stream(), parallelStream()方法"></a>1. Collection接口的stream(), parallelStream()方法</h3><p>Collection接口，即各种集合类的最上层的接口，支持通过stream(), parallelStream()方法产生Stream。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中spliterator()返回Spliterator接口，该接口用于对collection进行遍历或分片（parallelStream的情况下）。</p>
<h3 id="2-Stream接口及其实现ReferencePipeline"><a href="#2-Stream接口及其实现ReferencePipeline" class="headerlink" title="2. Stream接口及其实现ReferencePipeline"></a>2. Stream接口及其实现ReferencePipeline</h3><p>Stream接口支持一系列操作，包括filter, map, distinct, sorted, peak, limit, skip等方法，这些方法仍然返回Stream接口，还支持reduce, forEach, min, max, collect, count, toArray等方法，这些方法不再返回Stream接口，是对流式操作的结束操作，是TerminalOp。</p>
<p>Stream接口的具体实现是ReferencePipeline类，执行具体的操作。具体可查看源码，此处不展开。</p>
<p>对于parallelStream不同的操作有不同的实现，各自的实现会决定是否真正并行操作。例如，reduce操作会调用ReduceOps执行具体操作，ReduceOps中ReduceOp类的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                 Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReduceTask&lt;&gt;(<span class="keyword">this</span>, helper, spliterator).invoke().get();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中ReduceTask实现了ForkJoinTask，表明它是通过fork/join框架实现的并行处理。</p>
<p><strong>参考文献【3】<a href="https://objcoding.com/2019/03/04/lambda/#top" target="_blank" rel="noopener">^3</a>【4】<a href="https://github.com/CarpenterLee/JavaLambdaInternals" target="_blank" rel="noopener">^4</a>中对StreamAPI原理有更详细的解释，这块后续我再更新。</strong></p>
<h3 id="3-generator-生成器"><a href="#3-generator-生成器" class="headerlink" title="3. generator 生成器"></a>3. generator 生成器</h3><p>Stream为生成器的创建提供了便捷，生成器的好处是只有在你需要的时候才生成数据或对象，不需要提前生成。</p>
<p>例如，IntStream的generate()方法就生成一个流，可以无限调用生成整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">generate</span><span class="params">(IntSupplier s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Objects.requireNonNull(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> StreamSupport.intStream(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">new</span> StreamSpliterators.InfiniteSupplyingSpliterator.OfInt(Long.MAX_VALUE, s), <span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2019/12/01/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/01/HTTP/" class="post-title-link" itemprop="url">HTTPS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 18:39:21" itemprop="dateCreated datePublished" datetime="2019-12-01T18:39:21+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-01 23:56:22" itemprop="dateModified" datetime="2020-01-01T23:56:22+08:00">2020-01-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTTPS-HTTP-over-SSL"><a href="#HTTPS-HTTP-over-SSL" class="headerlink" title="HTTPS(HTTP over SSL)"></a>HTTPS(HTTP over SSL)</h1><p>HTTPS 实际上是HTTP over SSL，即在原来的HTTP协议层与TCP协议层之间加入SSL协议层，负责对数据通道进行加密。</p>
<p>TLS/SSL产生的背景是HTTP明文传输带来的几个问题：</p>
<p>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。</p>
<p>（2） 篡改风险（tampering）：第三方可以修改通信内容。</p>
<p>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>因此要达成的目标是：加密传输（防窃听）、数字签名校验（防篡改）、身份证书（防冒充），基于这三个目标来了解TLS/SSL的工作原理就比较清晰了，能明确每一个部分设计的原因。</p>
<p>PS : HTTPS 默认端口为443，而HTTP默认端口为80</p>
<h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p>先来了解一下TLS/SSL的前世今生。</p>
<p>SSL(Secure Socket Layer)，由网景公司开发，3.0版本开始标准化为TLS。</p>
<p>TLS(Transport Layer Security)是SSL的标准化后的产物，有1.0 1.1 1.2三个版本，默认使用1.0</p>
<p>TLS是SSL的标准化后的产物，现在实际使用的是TLS，由于习惯原因仍经常称之为SSL。</p>
<h3 id="协议工作流程"><a href="#协议工作流程" class="headerlink" title="协议工作流程"></a>协议工作流程</h3><p>安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake），协议栈如下：</p>
<img src="/2019/12/01/HTTP/ssl protocal" alt="img" style="zoom:50%;">

<p>其中记录协议负责数据的分片、压缩、验证、加密等，握手协议负责客户端与服务端的握手，秘钥交换，告警等。整体流程如下图所示。</p>
<img src="/2019/12/01/HTTP/ssl handshake" alt="img" style="zoom:50%;">

<p>或者如下图所示：</p>
<img src="/2019/12/01/HTTP/ssl handshake 1" alt="img" style="zoom:50%;">



<p>简单的SSL握手连接过程(仅server端交换证书给client)，详情可见参考文献[3]：</p>
<ul>
<li><p>1.client发送ClientHello，指定版本，随机数(RN)，所有支持的密码套件(CipherSuites)</p>
<p>ClientHello附带的数据随机数据RN，会在生成session key时使用，Cipher suite列出了client支持的所有加密算法组合，每一组包含3种算法，一个是非对称算法，如RSA，一个是对称算法如DES，3DES，RC4等，一个是Hash算法，如MD5，SHA等，server会从这些算法组合中选取一组，作为本次SSL连接中使用。 </p>
</li>
<li><p>2.server回应ServerHello，指定版本，RN，选择CipherSuites，会话ID(Session ID)</p>
<p>ServerHello包含一个session id，如果SSL连接断开，再次连接时，可以使用该属性重新建立连接，在双方都有缓存的情况下可以省略握手的步骤。server端也会生成随机的RN，用于生成session key使用。server会从client发送的Cipher suite列表中挑出一个，例如RSA+RC4+MD5。</p>
</li>
</ul>
<p><strong>client接到ServerHello并处理后，双发状态是已经协商好了一组算法，包括对称加密、非对称加密、摘要，以及后续计算对称秘钥用的随机数</strong>。</p>
<ul>
<li><p>3.server发送Certificate<br>server的证书信息，只包含public key，server保存有public key对应的private key，用于证明server是该证书的实际拥有者。</p>
<p>那么如何验证呢？原理很简单：client随机生成一串数，用server的public key加密(显然是RSA算法)，发给server，server用private key解密后返回给client，client与原文比较，如果一致，则说明server拥有private key，也就说明与client通信的正是证书的拥有者。</p>
<p>利用这个原理，就可以实现session key的交换，加密前的那串随机数就可用作session key，因为除了client和server，没有第三方能获得该数据了。实际上session key的交换也是这么做的。<br>原理很简单，实际使用时会复杂很多，数据经过多次hash，伪随机等的运算，前面提到的client和server端得RN都会参与计算。这个原理用于下面client发送ClientKeyExchange前进行session key的计算。</p>
</li>
</ul>
<p><strong>client拿到了server的public key。</strong></p>
<ul>
<li><p>4.Server发送ServerHelloDone</p>
</li>
<li><p>5.client发送ClientKeyExchange，用于与server交换session key<br>client随机生成48字节的pre-master secret，padding后用public key加密得到130字节的数据发送给server，server解密也能得到pre-master secret。</p>
</li>
</ul>
<p>双方使用pre-master secret、”master secret”常量字节流、前期交换的server端RN和client的RN作为参数，使用一个伪随机函数PRF，其实就是hash之后再hash，最后得到48字节的master secret。master secret再与”key expansion”常量，双方RN经过伪随机函数运算得到key_block，PRF伪随机函数可以循环输出数据，因此我们想得到多少字节都可以，就如Random伪随机函数，给它一个种子，后续用hash计算能得到无数个随机数，如果每次种子相同，得到的序列是一样的，但是这里的输入时48字节的master secret，2个28字节的RN和一个字符串常量，碰撞的可能性是很小的。得到key block后，算法就从中取出session key，IV(对称算法中使用的初始化向量)等。client和server使用的session key是不一样的，但只要双方都知道对方使用的是什么就行了。这里会取出4个：client/server加密正文的key，client/server计算handshake数据hash的key。</p>
<p><strong>注意双方只交换了pre-master key，后续的计算都是独立完成的，由于算法和种子都一样，所以得到的session key也一致。</strong></p>
<p><strong>server接到ClientKeyExchange处理后，双方状态是已经协商好了对称秘钥，后续再利用对称秘钥进行一次验证</strong>。</p>
<ul>
<li><p>6.client发送ChangeCipherSpec，指示Server从现在开始发送的消息都是加密过的</p>
</li>
<li><p>7.client发送Finishd，包含了前面所有握手消息的hash，可以让server验证握手过程是否被第三方篡改</p>
<p>Finishd：client发送的加密数据，这个消息非常关键，一是能证明握手数据没有被篡改过，二能证明自己确实是session key的拥有者(这里是单边验证，只有server有certificate，server发送的Finished能证明自己含有private key，原理是一样的)。</p>
<p>client将之前发送的所有握手消息存入handshake messages缓存，进行MD5和SHA-1两种hash运算，再与前面的master secret和一串常量”client finished”进行PRF伪随机运算得到12字节的verify data，还要经过改进的MD5计算得到加密信息。为什么能证明上述两点呢，前面说了只有密钥的拥有者才能解密得到pre-master key，master key，最后得到key block后，进行hash运算得到的结果才与发送方的一致。</p>
</li>
<li><p>8.server发送ChangeCipherSpec，指示Client从现在开始发送的消息都是加密过的</p>
</li>
<li><p>9.server发送Finishd，包含了前面所有握手消息的hash，可以让client验证握手过程是否被第三方篡改，并且证明自己是Certificate密钥的拥有者（因为如果不是，那么无法得到pre-master key，也就无法计算得到session key），即证明自己的身份。</p>
</li>
</ul>
<p>握手完成后，客户端和服务端完成了对称秘钥session key的交换，数据通过对称秘钥加密后进行传输，实现了加密的数据传输通道。</p>
<h3 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h3><img src="/2019/12/01/HTTP/ca cert" alt="img" style="zoom:50%;">

<p>上面的握手流程讲完并没有描述数字证书扮演的角色，以及服务端向客户端返回证书，客户端进行验证的过程，这部分过程见上图。</p>
<p>服务端，即站点先向CA申请证书，申请信息中带有自己生成的公钥信息，CA审核通过后签发证书，证书包含服务端公钥、证书签名，证书签名为将证书明文部分计算数字摘要后，用CA的私钥加密的签名，防止证书被篡改（后面会讲到数字签名这块）。证书申请与签发是由站点先行完成的。</p>
<p>客户端在与服务端握手的过程中拿到证书，由于证书明文部分带有证书的公钥信息，能用CA的公钥对签名进行解密，并通过对比解密后的数字摘要与自己用明文计算的数字摘要来验证信息是否被篡改，从而保证了证书的安全性。后续通过证书中的server公钥来验证该server为证书拥有者，原理见上面的握手流程。</p>
<p>CA证书的安全使得客户端可以验证服务端的身份，防止站点被冒充，即钓鱼网站。</p>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>加密和解密使用相同的密钥，计算较快，安全性较差。在SSL中常用的对称加密算法有RC4,AES,3DES,Camellia等。</p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>加密和解密使用不同的密钥，数据在一端用公钥加密后，在另一端用私钥解密，安全性较高。由于性能问题，非对称加密一般用于数字签名（前面提到的证书的签名）和秘钥（对称加密算法的秘钥）的交换。常见的算法有RSA、DSA、ECC。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名就是“非对称加密+摘要算法”，其目的不是为了加密，而是用来防止他人篡改数据。<br>其核心思想是：比如A要给B发送数据，A先用摘要算法得到数据的指纹，然后用A的私钥加密指纹，加密后的指纹就是A的签名，B收到数据和A的签名后，也用同样的摘要算法计算指纹，然后用A公开的公钥解密签名，比较两个指纹，如果相同，说明数据没有被篡改，确实是A发过来的数据。假设C想改A发给B的数据来欺骗B，因为篡改数据后指纹会变，要想跟A的签名里面的指纹一致，就得改签名，但由于没有A的私钥，所以改不了，如果C用自己的私钥生成一个新的签名，B收到数据后用A的公钥根本就解不开。</p>
<p>至于为什么要使用摘要算法是因为非对称加密算法对原文长度有要求，所以先通过摘要算法生成一段较短的指纹，再进行非对称加密</p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>摘要算法不是用来加密的，其输出长度固定，相当于计算数据的指纹，主要用来做数据校验，验证数据的完整性和正确性。常见的算法有CRC、MD5、SHA1、SHA256。<br>CRC32:CRC本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。由于CRC32产生校验值时源数据块的每一个bit（位）都参与了计算，所以数据块中即使只有一位发生了变化，也会得到不同的CRC32值。</p>
<h1 id="HTTP-短连接-vs-长连接"><a href="#HTTP-短连接-vs-长连接" class="headerlink" title="HTTP 短连接 vs 长连接"></a>HTTP 短连接 vs 长连接</h1><p>下面来聊一下短连接与长连接。</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。HTTP的短连接、长连接实际上指的是TCP协议的短连接、长连接，长连接即是指多个HTTP请求复用一个TCP连接。</p>
<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等，当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<p>Connection:keep-alive 服务器和客户端都要设置</p>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><p>TCP连接的建立与释放分别对应的是三次握手与四次挥手，具体如下图：</p>
<img src="/2019/12/01/HTTP/tcp handshake" alt="img" style="zoom:75%;">





<img src="/2019/12/01/HTTP/tcp fin" alt="img" style="zoom:75%;">



<h1 id="HTTP-2-多路复用"><a href="#HTTP-2-多路复用" class="headerlink" title="HTTP/2 多路复用"></a>HTTP/2 多路复用</h1><p>详细可参考此文：<a href="https://blog.wangriyu.wang/2018/05-HTTP2.html，作者写的非常详细：）" target="_blank" rel="noopener">https://blog.wangriyu.wang/2018/05-HTTP2.html，作者写的非常详细：）</a></p>
<h6 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h6><p>[1] <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>[2] <a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener">https://blog.csdn.net/ustccw/article/details/76691248</a></p>
<p>[3] <a href="https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html" target="_blank" rel="noopener">https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html</a></p>
<p>[4] <a href="https://blog.csdn.net/huangyuhuangyu/article/details/78220005" target="_blank" rel="noopener">https://blog.csdn.net/huangyuhuangyu/article/details/78220005</a></p>
<p>[5] <a href="https://blog.wangriyu.wang/2018/05-HTTP2.html" target="_blank" rel="noopener">https://blog.wangriyu.wang/2018/05-HTTP2.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">pcl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pcl</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
