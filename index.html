<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://pclhahaha.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="个人笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;pclhahaha.github.io&#x2F;index.html">
<meta property="og:site_name" content="个人笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://pclhahaha.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>个人笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/01/04/spring_start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/spring_start/" class="post-title-link" itemprop="url">Spring Boot/Spring的启动过程分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-04 21:01:19 / 修改时间：21:00:06" itemprop="dateCreated datePublished" datetime="2020-01-04T21:01:19+08:00">2020-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Spring-Boot-Spring的启动过程分析"><a href="#Spring-Boot-Spring的启动过程分析" class="headerlink" title="Spring Boot/Spring的启动过程分析"></a>Spring Boot/Spring的启动过程分析</h1><h2 id="一、Spring-Boot启动"><a href="#一、Spring-Boot启动" class="headerlink" title="一、Spring Boot启动"></a>一、Spring Boot启动</h2><p>先来一段众所周知的spring boot的启动入口代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>里面的核心代码如下，各步骤已添加注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * Run the Spring application, creating and refreshing a new</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">		stopWatch.start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		ConfigurableApplicationContext context = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">		configureHeadlessProperty();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">		* 获取META-INF/spring.factories中配置的SpringApplicationRunListener类型的监听器</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">		* 默认只有一个listener是org.springframework.boot.context.event.EventPublishingRunListener</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">		SpringApplicationRunListeners listeners = getRunListeners(args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//EventPublishingRunListener发布ApplicationStartingEvent事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		listeners.starting();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">			ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">			<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			* 创建并配置Environment（主要是PropertySource和Profile）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			*之后调用监听器的environmentPrepared方法，触发EventPublishingRunListener发布ApplicationEnvironmentPreparedEvent事件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			* 将Environment与Application绑定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//设置spring.beaninfo.ignore系统属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">			configureIgnoreBeanInfo(environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//打印banner</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">			Banner printedBanner = printBanner(environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 根据应用类型创建ApplicationContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 例如web应用创建的是AnnotationConfigServletWebServerApplicationContext</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      **/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">			context = createApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//获取配置的异常上报类，用于后续异常上报</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">					new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * prepareContext内部逻辑：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 1. postProcessApplicationContext：配置bean工厂的beanNameGenerator，ConversionService及context的resourceLoader</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 2. applyInitializers使用META-INF/spring.factories中配置的ApplicationContextInitializer初始化ApplicationContext，默认配了7个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 3. 调用监听器的contextPrepared方法，触发EventPublishingRunListener发布ApplicationContextInitializedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 4. 获取beanFactory并配置（默认是DefaultListableBeanFactory，此时已有几个spring内部的bean已注册），如注册springApplicationArguments单例类，设置allowBeanDefinitionOverriding参数等，配置懒加载LazyInitializationBeanFactoryPostProcessor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 5. 加载bean，看源码是支持xml读取，annotation扫描，甚至groovy，实际上只加载了入口类也就是上面的Application类，将其注册为单例并获取了其注解原数据，即<span class="doctag">@SpringBootApplication</span>注解</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      * 6. 调用监听器的contextLoaded方法，触发EventPublishingRunListener发布ApplicationPreparedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="comment">      **/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">			prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">			<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			* 调用AbstractApplicationContext的refresh方法，然后注册shutdownhook，这一步核心其实就是spring的启动了，这个在第3节展开</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment">			**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">      refreshContext(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">			afterRefresh(context, applicationArguments);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">			stopWatch.stop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//调用监听器的started方法，触发EventPublishingRunListener发布ApplicationStartedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">			listeners.started(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//调用ApplicationRunner，然后调用CommandLineRunner</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">			callRunners(context, applicationArguments);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//里面有一步是：调用监听器的failed方法，触发EventPublishingRunListener发布ApplicationFailedEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//调用监听器的running方法，触发EventPublishingRunListener发布ApplicationReadyEvent</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">			listeners.running(context);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> context;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr></table></figure>
<p>可以看到spring boot的启动是在spring启动的基础上增加了一些特性，例如根据应用类型推断并指定ApplicationContext的具体实现，各阶段事件的发布（提供了一个扩展点），调用ApplicationRunner，CommandLineRunner（又一个扩展点）等。下面来一张详细的流程图，个人觉得这个图画的很好<a href="(https://www.cnblogs.com/l3306/p/10752907.html)">^1</a>，可以参考该图一步步看源码。</p>
<p><strong>PS：推荐先粗读一遍源码，然后对应用进行debug，一步步看执行逻辑以及每个步骤执行完毕后的数据以及状态，可以对细节有更好的理解。例如，有些变量是在构造器初始化时加载的配置，这个光看源码很难看到。</strong></p>
<p><img src="/2020/01/04/spring_start/1158841-20190707171658626-1389392187.png" alt="img"></p>
<h2 id="二、Spring-Boot自动化配置"><a href="#二、Spring-Boot自动化配置" class="headerlink" title="二、Spring Boot自动化配置"></a>二、Spring Boot自动化配置</h2><h3 id="1-EnableAutoConfiguration"><a href="#1-EnableAutoConfiguration" class="headerlink" title="1. @EnableAutoConfiguration"></a>1. @EnableAutoConfiguration</h3><p><img src="/2020/01/04/spring_start/1650e0e47481e59a.png" alt="img"></p>
<p>spring boot提供了自动配置，@SpringBootApplication注解中的@EnableAutoConfiguration注解是spring boot自动配置的关键，原理可阅读文章【2】<a href="(https://juejin.im/post/5b679fbc5188251aad213110)">^2</a>，以后有机会再展开详细描述。</p>
<h3 id="2-META-INF-spring-factories"><a href="#2-META-INF-spring-factories" class="headerlink" title="2. META-INF/spring.factories"></a>2. META-INF/spring.factories</h3><p>上面说到@EnableAutoConfiguration注解通过读取META-INF/spring.factories配置文件实现自动配置，这里说一下META-INF/spring.factories配置文件。</p>
<ol>
<li>配置是K/V对，key是接口的全限定名，value是该接口的实现类的名字，可以是逗号分隔的多个值，示例如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">example.MyService&#x3D;example.MyServiceImpl1,example.MyServiceImpl2</span></pre></td></tr></table></figure>

<ol start="2">
<li><p>META-INF/spring.factories配置文件可在多个jar中配置，基于这个我们可以实现自己的自动配置类，并将其配置在自己的jar的META-INF/spring.factories配置文件中，spring boot会帮我们完成自动配置。</p>
</li>
<li><p>spring boot自带的META-INF/spring.factories配置文件里已经配置了许多这样的配置项。</p>
</li>
<li><p>借助spring框架的SpringFactoriesLoader可以加载META-INF/spring.factories配置文件，SpringFactoriesLoader属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件META-INF/spring.factories加载配置。</p>
</li>
</ol>
<p><strong>是不是有点像java的SPI加载机制</strong></p>
<h2 id="三、Spring的启动"><a href="#三、Spring的启动" class="headerlink" title="三、Spring的启动"></a>三、Spring的启动</h2><p>上面提到调用了AbstractApplicationContext的refresh()方法，其实就是spring启动时执行的方法，里面的执行顺序是固定的。</p>
<h3 id="1-AbstractApplicationContext的refresh-方法"><a href="#1-AbstractApplicationContext的refresh-方法" class="headerlink" title="1. AbstractApplicationContext的refresh()方法"></a>1. AbstractApplicationContext的refresh()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      prepareRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     	<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	* obtainFreshBeanFactory()方法内部调用refreshBeanFactory()，其默认实现由AbstractRefreshableApplicationContext提供，逻辑是：销毁原来的bean，关闭原来的bean factory，创建新的DefaultListableBeanFactory，调用loadBeanDefinitions()方法加载bean，这部分在后面详细展开；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	不过在spring boot的情况下这里的实现是AnnotationConfigServletWebServerApplicationContext类，并不会销毁原来的bean以及bean factory。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">     	<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     	* 摘自该方法的注释，主要是配置bean factory</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    	* Configure the factory's standard context characteristics,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 		* such as the context's ClassLoader and post-processors.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 		**/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      prepareBeanFactory(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">       	 <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">       	 * 摘自该方法的注释，主要是注册BeanPostProcessors</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * Modify the application context's internal bean factory after its standard</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * initialization. All bean definitions will have been loaded, but no beans</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * will have been instantiated yet. This allows for registering special</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">         postProcessBeanFactory(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 这一步会调用BeanFactoryPostProcessor，其中有一个是ConfigurationClassPostProcessor，扫描@Configuration注解标注的类，并完成相应的bean definition的注册</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">         registerBeanPostProcessors(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Initialize message source for this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">         initMessageSource();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">         initApplicationEventMulticaster();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">       	 <span class="comment">// web应用的情况下会检查是否有WebServer，若没有则新建一个WebServer，spring boot默认是tomcat</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">         onRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 注册ApplicationListener类型的bean，并将之前发过的ApplicationEvent再发一遍</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">         registerListeners();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 完成bean factory的初始化，并将剩余的未实例化的单例bean实例化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">         finishBeanFactoryInitialization(beanFactory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * Finish the refresh of this context, invoking the LifecycleProcessor's</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * onRefresh() method and publishing the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         * &#123;@link org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment">         */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">         finishRefresh();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">         destroyBeans();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Reset 'active' flag.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">         cancelRefresh(ex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Propagate exception to caller.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">         <span class="keyword">throw</span> ex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">         resetCommonCaches();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这块每一步的逻辑都相当复杂，涉及spring bean容器的很多特性以及扩展点，这些都需要具体去了解，后续再补上每一步的详情，先mark一下。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文基于spring-boot:2.2.1.RELEASE版本，只是粗略过了一遍启动流程，有些部分可能理解有误，内部细节还有待继续研究。另外不得不说，看spring源码是真的累。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/01/04/tomcat_spring_web_application/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/tomcat_spring_web_application/" class="post-title-link" itemprop="url">Tomcat中部署spring web application</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-04 21:01:19 / 修改时间：21:00:06" itemprop="dateCreated datePublished" datetime="2020-01-04T21:01:19+08:00">2020-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Tomcat中部署spring-web-application"><a href="#Tomcat中部署spring-web-application" class="headerlink" title="Tomcat中部署spring web application"></a>Tomcat中部署spring web application</h1><h2 id="一、Servlet容器"><a href="#一、Servlet容器" class="headerlink" title="一、Servlet容器"></a>一、Servlet容器</h2><p>java的web应用是基于Servlet的，Tomcat是比较有名的Servlet容器，一个Tomcat中可以部署多个Servlet。下图是Tomcat的容器模型。</p>
<p><img src="/2020/01/04/tomcat_spring_web_application/image002.jpg" alt="图 1 . Tomcat 容器模型"></p>
<p>有关Servlet与Tomcat的原理推荐阅读下面几篇文章进行了解：</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/</a></p>
<p><a href="http://objcoding.com/2019/05/30/tomcat-architecture/" target="_blank" rel="noopener">http://objcoding.com/2019/05/30/tomcat-architecture/</a></p>
<h3 id="1-Tomcat中war的部署"><a href="#1-Tomcat中war的部署" class="headerlink" title="1. Tomcat中war的部署"></a>1. Tomcat中war的部署</h3><p>web应用以war包的形式部署在Tomcat中，web.xml是web应用的部署配置文件，下面说说其中的一些配置元素。</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>servlet</td>
<td>指定servlet</td>
</tr>
<tr>
<td>servlet-mapping</td>
<td>指定servlet与url之间的映射关系</td>
</tr>
<tr>
<td>filter</td>
<td>指定filter</td>
</tr>
<tr>
<td>filter-mapping</td>
<td>指定filter与url之间的映射关系</td>
</tr>
<tr>
<td>listener</td>
<td>指定监听器监听servlet上下文事件</td>
</tr>
<tr>
<td>context-param</td>
<td>servlet上下文初始化参数</td>
</tr>
<tr>
<td>welcome-file-list</td>
<td>一般用于指定欢迎页，如index.jsp</td>
</tr>
</tbody></table>
<p>以上是对servlet容器的简单介绍，以及在Tomcat中以war部署web应用时，web.xml的作用。</p>
<h2 id="二、Tomcat中启动spring"><a href="#二、Tomcat中启动spring" class="headerlink" title="二、Tomcat中启动spring"></a>二、Tomcat中启动spring</h2><p>在Tomcat中启动spring也就意味着如何启动并初始化spring上下文，在web应用中该上下文就是WebApplicationContext。</p>
<h3 id="1-ContextLoadListener"><a href="#1-ContextLoadListener" class="headerlink" title="1. ContextLoadListener"></a>1. ContextLoadListener</h3><p>WebApplicationContext可以通过在web.xml中配置ContextLoadListener这个listener实现初始化。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span></pre></td></tr></table></figure>

<p>ContextLoaderListener实现了ServletContextListener，该接口定义了两个方法可监听servlet的初始化与销毁，该接口的实现类也就是ContextLoaderListener有3种方式可接收到这两个通知事件：</p>
<ol>
<li><p>定义在web.xml配置文件中，也就是本文描述的方式；</p>
</li>
<li><p>加上javax.servlet.annotation.WebListener注解；</p>
</li>
<li><p>通过ServletContext的addListener方法添加；</p>
</li>
</ol>
<p>ContextLoaderListener在配置时需要注意：如果使用了org.springframework.web.util.Log4jConfigListener，需要在web.xml中将该listener配置在其之后。Log4jConfigListener用于初始化定制化的log4j。</p>
<h3 id="2-WebApplicationContext的创建"><a href="#2-WebApplicationContext的创建" class="headerlink" title="2. WebApplicationContext的创建"></a>2. WebApplicationContext的创建</h3><p>ContextLoaderListener将具体的创建WebApplicationContext的操作委派给ContextLoader执行，其关键方法是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span></span></span></pre></td></tr></table></figure>

<p>initWebApplicationContext先创建一个WebApplicationContext，然后完成配置并调用refresh()方法。</p>
<ol>
<li><p>WebApplicationContext的默认实现是XmlWebApplicationContext（配置在spring-web包中的ContextLoader.properties文件中），可以通过指定contextClass参数指定WebApplicationContext的实现，当然一般不会这么做。</p>
</li>
<li><p>WebApplicationContext初始化的配置文件地址可以通过在web.xml文件中的context-param配置节中配置contextConfigLocation参数指定，如：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">			classpath*:config/spring/local/appcontext-*.xml,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">			classpath*:config/spring/appcontext-*.xml</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span></pre></td></tr></table></figure>
<p>​        PS:存在多个配置文件地址的情况下，后面文件中定义的的bean definition会覆盖前面的。</p>
<p>还有一些其他的可配置参数可以影响WebApplicationContext的创建，这里没有全部列出，这些一般也是非常用的功能。</p>
<ol start="3">
<li>调用refresh()方法实际上是调用了AbstractApplicationContext的refresh()方法，里面就是标准的spring的ApplicationContext的启动流程，主要是BeanFactory的初始化以及相应的bean的加载与初始化，具体可参考我的另一篇文章《Spring Boot/Spring的启动过程分析》。</li>
</ol>
<h3 id="3-DispatchServlet"><a href="#3-DispatchServlet" class="headerlink" title="3. DispatchServlet"></a>3. DispatchServlet</h3><p>DispatchServlet是将HTTP请求分发至handlers或者controllers的中央分发器，提供了便利的映射和异常处理功能。下面列一下它的一些特性：</p>
<ol>
<li>一个web应用可以配置多个DispatcherServlet，每个DispatcherServlet在自己的命名空间内运行，加载自己私有的包含了mapping的应用上下文。只有通过ContextLoaderListener加载的上下文是共享的。</li>
<li>通过HandlerMapping的实现类来实现请求request到相应的handler的映射，可覆盖默认实现，默认实现是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span></pre></td></tr></table></figure></li>
<li>HandlerAdapter接口，用来适配请求和handler，可覆盖默认实现，默认实现是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter对应org.springframework.web.HttpRequestHandler</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter对应org.springframework.web.servlet.mvc.Controller</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">另外还有一个默认的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span></pre></td></tr></table></figure></li>
<li>HandlerExceptionResolver负责dispatcher的异常处理策略，例如，发生某些特定异常时映射到某个错误页面。<br>这里只列出一些基础的，还有一些关于ViewResolver，MultipartResolver，LocaleResolver，ThemeResolver的没有列出，感兴趣的可以研究一下。</li>
</ol>
<h4 id="DispatchServlet的创建"><a href="#DispatchServlet的创建" class="headerlink" title="DispatchServlet的创建"></a>DispatchServlet的创建</h4><p>DispatchServlet继承了FrameworkServlet，FrameworkServlet继承了HttpServletBean，HttpServletBean继承了HttpServlet。<br>servlet容器启动的时候会调用HttpServlet的init()方法，也就是说会调用HttpServletBean的init()方法，其中会调用FrameworkServlet的initServletBean()方法，其中会调用它的initWebApplicationContext()方法，创建这个DispatchServlet的ApplicationContext，并且会将ContextLoaderListener加载的ApplicationContext作为其parent。</p>
<p>那么如何才能让servlet容器去创建一个DispatchServlet呢？答案就是在web.xml中进行配置，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        &lt;init-param&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            &lt;param-value&gt;classpath:config&#x2F;spring.mvc&#x2F;appcontext-servlet.xml&lt;&#x2F;param-value&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        &lt;&#x2F;init-param&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &lt;&#x2F;servlet&gt;</span></pre></td></tr></table></figure>
<p>其中<code>contextConfigLocation</code>参数指定这个DispatcherServlet的ApplicationContext的配置，<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>表示在容器启动时就加载。</p>
<p>好了，再往下就是spring mvc的内容了，还有待研究。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文基于对spring 3.2.5版本的源码阅读，目前spring最新版本已到5.2.x，内容上可能有些过时，但理论上不影响对spring框架的理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2020/01/01/java_lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/java_lambda/" class="post-title-link" itemprop="url">Java 函数式编程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-01 22:15:07 / 修改时间：23:56:25" itemprop="dateCreated datePublished" datetime="2020-01-01T22:15:07+08:00">2020-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Java-函数式编程"><a href="#Java-函数式编程" class="headerlink" title="Java 函数式编程"></a>Java 函数式编程</h1><h2 id="一、函数式接口"><a href="#一、函数式接口" class="headerlink" title="一、函数式接口"></a>一、函数式接口</h2><h3 id="1-FunctionalInterface注解"><a href="#1-FunctionalInterface注解" class="headerlink" title="1. @FunctionalInterface注解"></a>1. @FunctionalInterface注解</h3><p>@FunctionalInterface注解：作用于接口，表示该接口是函数式接口（functional interface）。</p>
<p>函数式接口有以下几个特点：</p>
<ol>
<li><p>函数式接口有且只有一个抽象方法</p>
</li>
<li><p>默认方法不计入抽象方法的个数，静态方法也不计入抽象方法个数</p>
</li>
<li><p>覆盖java.lang.Object的方法的方法也不计入抽象方法的个数</p>
</li>
<li><p>函数式接口可以通过lambda表达式、方法引用、构造器引用来创建实例</p>
</li>
<li><p>对于编译器来说，只要一个接口符合函数式接口的定义就会将其当作函数式接口，不一定需要@FunctionalInterface注解标注，注解用于检查该接口是否只包含一个抽象方法</p>
</li>
</ol>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloFuncInterface</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-JDK中的函数式接口"><a href="#2-JDK中的函数式接口" class="headerlink" title="2. JDK中的函数式接口"></a>2. JDK中的函数式接口</h3><p>java.lang.Runnable</p>
<p>java.awt.event.ActionListener</p>
<p>java.util.Comparator</p>
<p>java.util.concurrent.Callable</p>
<p>java.util.function包下的接口，如Consumer、Predicate、Supplier等</p>
<h2 id="二、lambda表达式"><a href="#二、lambda表达式" class="headerlink" title="二、lambda表达式"></a>二、lambda表达式</h2><p>lambda表达式用来实现函数式接口。</p>
<h3 id="1-lambda表达式形式"><a href="#1-lambda表达式形式" class="headerlink" title="1. lambda表达式形式"></a>1. lambda表达式形式</h3><p><code>(params) -&gt; expression</code><br><code>(params) -&gt; statement</code><br><code>(params) -&gt; { statements }</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 通过lambda表达式实现自定义的函数式接口(注：JAVA 8 之前一般是用匿名类实现的)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    HelloFuncInterface helloFuncInterface = () -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"hello"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    helloFuncInterface.hello();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-lambda表达式替换匿名类，减少冗余代码"><a href="#2-lambda表达式替换匿名类，减少冗余代码" class="headerlink" title="2. lambda表达式替换匿名类，减少冗余代码"></a>2. lambda表达式替换匿名类，减少冗余代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">":runnable by lambda expression"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;).start();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":runnable by anonymous class"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;).start();</span></pre></td></tr></table></figure>



<h2 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h2><p>方法引用由::双冒号操作符标示，看起来像C++的作用域解析运算符。<strong>实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！至于返回值就不作要求</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 方法引用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodReference</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    List&lt;String&gt; pets = Arrays.asList(<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"snake"</span>, <span class="string">"squirrel"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    pets.forEach((a) -&gt; System.out.println(a));<span class="comment">//lambda表达式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    pets.forEach(System.out::println);<span class="comment">//方法引用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="1-引用方法-1"><a href="#1-引用方法-1" class="headerlink" title="1. 引用方法^1"></a>1. 引用方法<a href="https://blog.csdn.net/TimHeath/article/details/71194938" target="_blank" rel="noopener">^1</a></h3><ul>
<li>对象引用::实例方法名</li>
</ul>
<p>System.out是一个静态成员变量对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">consumer.accept(<span class="string">"hello"</span>);</span></pre></td></tr></table></figure>

<ul>
<li>类名::静态方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Function&lt;Long, Long&gt; abs = Math::abs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">System.out.println(abs.apply(-<span class="number">3L</span>));</span></pre></td></tr></table></figure>

<ul>
<li>类名::实例方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;String, String&gt; b = String::equals;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">System.out.println(b.test(<span class="string">"abc"</span>, <span class="string">"abcd"</span>));</span></pre></td></tr></table></figure>

<h3 id="2-引用构造器"><a href="#2-引用构造器" class="headerlink" title="2. 引用构造器"></a>2. 引用构造器</h3><p>在引用构造器的时候，构造器参数列表要与接口中抽象方法的参数列表一致,格式为 类名::new。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, StringBuffer&gt; fun = StringBuffer::<span class="keyword">new</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">StringBuffer buffer = fun.apply(<span class="number">10</span>);</span></pre></td></tr></table></figure>
<p>Function接口的apply方法接收一个参数，并且有返回值。在这里接收的参数是Integer类型，与StringBuffer类的一个构造方法StringBuffer(int capacity)对应，而返回值就是StringBuffer类型。上面这段代码的功能就是创建一个Function实例，并把它apply方法实现为创建一个指定初始大小的StringBuffer对象。</p>
<h3 id="3-引用数组"><a href="#3-引用数组" class="headerlink" title="3. 引用数组"></a>3. 引用数组</h3><p>引用数组和引用构造器很像，格式为 类型[]::new，其中类型可以为基本类型也可以是类。如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer[]&gt; fun2 = Integer[]::<span class="keyword">new</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Integer[] arr2 = fun2.apply(<span class="number">10</span>);</span></pre></td></tr></table></figure>

<h2 id="四、java-util-function"><a href="#四、java-util-function" class="headerlink" title="四、java.util.function"></a>四、java.util.function</h2><h3 id="1-Predicate接口"><a href="#1-Predicate接口" class="headerlink" title="1. Predicate接口"></a>1. Predicate接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Predicate是一个函数式接口，也是一个泛型接口，作用是对传入的一个泛型参数进行判断，并返回一个boolean值，任何符合这一条件的lambda表达式都可以转为Predicate接口，该接口的实现一般用于集合过滤等。下面提供一些例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * lambda表达式加Predicate接口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">predicateDemo</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    List&lt;String&gt; pets = Arrays.asList(<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"snake"</span>, <span class="string">"squirrel"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//简单的Predicate接口示例</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(s -&gt; s.startsWith(<span class="string">"s"</span>)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    Predicate&lt;String&gt; startWith = s -&gt; s.startsWith(<span class="string">"s"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    Predicate&lt;String&gt; lengthPredicate = s -&gt; s.length() &gt; <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate支持and()操作将两个Predicate接口的逻辑取与</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate and() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(startWith.and(lengthPredicate)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate支持or()操作将两个Predicate接口的逻辑取或</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate or() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(startWith.or(lengthPredicate)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate支持negate()操作将Predicate接口的逻辑取反</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate negate() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(startWith.negate()).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//Predicate静态方法isEqual()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Predicate isEqual() demo:"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    pets.stream().filter(Predicate.isEqual(<span class="string">"cat"</span>)).forEach(System.out::println);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>从示例中可以看到，Predicate接口支持and(), or(), negate()等，并且有一个静态方法isEqual。</p>
<h3 id="2-Consumer接口"><a href="#2-Consumer接口" class="headerlink" title="2. Consumer接口"></a>2. Consumer接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        Objects.requireNonNull(after);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Consumer是一个函数式接口，也是一个泛型接口，作用是对传入的一个泛型参数进行操作，可能会对原数据产生side effect，即改变数据。常见的例子有：</p>
<ol>
<li>Iterable接口的forEach方法接受一个Comsumer接口类型的操作，对集合中的元素进行操作，例如打印等。</li>
</ol>
<h3 id="3-Function接口"><a href="#3-Function接口" class="headerlink" title="3. Function接口"></a>3. Function接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该接口代表接受一个参数并返回一个参数的操作类型。</p>
<h3 id="4-Supplier接口"><a href="#4-Supplier接口" class="headerlink" title="4. Supplier接口"></a>4. Supplier接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * Gets a result.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>该接口表示调用后返回一个参数的操作类型，返回结果不要求一定是新创建的或者不同的。</p>
<h2 id="五、StreamAPI原理"><a href="#五、StreamAPI原理" class="headerlink" title="五、StreamAPI原理"></a>五、StreamAPI原理</h2><h3 id="1-Collection接口的stream-parallelStream-方法"><a href="#1-Collection接口的stream-parallelStream-方法" class="headerlink" title="1. Collection接口的stream(), parallelStream()方法"></a>1. Collection接口的stream(), parallelStream()方法</h3><p>Collection接口，即各种集合类的最上层的接口，支持通过stream(), parallelStream()方法产生Stream。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中spliterator()返回Spliterator接口，该接口用于对collection进行遍历或分片（parallelStream的情况下）。</p>
<h3 id="2-Stream接口及其实现ReferencePipeline"><a href="#2-Stream接口及其实现ReferencePipeline" class="headerlink" title="2. Stream接口及其实现ReferencePipeline"></a>2. Stream接口及其实现ReferencePipeline</h3><p>Stream接口支持一系列操作，包括filter, map, distinct, sorted, peak, limit, skip等方法，这些方法仍然返回Stream接口，还支持reduce, forEach, min, max, collect, count, toArray等方法，这些方法不再返回Stream接口，是对流式操作的结束操作，是TerminalOp。</p>
<p>Stream接口的具体实现是ReferencePipeline类，执行具体的操作。具体可查看源码，此处不展开。</p>
<p>对于parallelStream不同的操作有不同的实现，各自的实现会决定是否真正并行操作。例如，reduce操作会调用ReduceOps执行具体操作，ReduceOps中ReduceOp类的部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                 Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReduceTask&lt;&gt;(<span class="keyword">this</span>, helper, spliterator).invoke().get();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>其中ReduceTask实现了ForkJoinTask，表明它是通过fork/join框架实现的并行处理。</p>
<p><strong>参考文献【3】<a href="https://objcoding.com/2019/03/04/lambda/#top" target="_blank" rel="noopener">^3</a>【4】<a href="https://github.com/CarpenterLee/JavaLambdaInternals" target="_blank" rel="noopener">^4</a>中对StreamAPI原理有更详细的解释，这块后续我再更新。</strong></p>
<h3 id="3-generator-生成器"><a href="#3-generator-生成器" class="headerlink" title="3. generator 生成器"></a>3. generator 生成器</h3><p>Stream为生成器的创建提供了便捷，生成器的好处是只有在你需要的时候才生成数据或对象，不需要提前生成。</p>
<p>例如，IntStream的generate()方法就生成一个流，可以无限调用生成整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">generate</span><span class="params">(IntSupplier s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    Objects.requireNonNull(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> StreamSupport.intStream(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">new</span> StreamSpliterators.InfiniteSupplyingSpliterator.OfInt(Long.MAX_VALUE, s), <span class="keyword">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://pclhahaha.github.io/2019/12/01/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="pcl">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/01/HTTP/" class="post-title-link" itemprop="url">HTTPS</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 18:39:21" itemprop="dateCreated datePublished" datetime="2019-12-01T18:39:21+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-01 23:56:22" itemprop="dateModified" datetime="2020-01-01T23:56:22+08:00">2020-01-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTTPS-HTTP-over-SSL"><a href="#HTTPS-HTTP-over-SSL" class="headerlink" title="HTTPS(HTTP over SSL)"></a>HTTPS(HTTP over SSL)</h1><p>HTTPS 实际上是HTTP over SSL，即在原来的HTTP协议层与TCP协议层之间加入SSL协议层，负责对数据通道进行加密。</p>
<p>TLS/SSL产生的背景是HTTP明文传输带来的几个问题：</p>
<p>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。</p>
<p>（2） 篡改风险（tampering）：第三方可以修改通信内容。</p>
<p>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。</p>
<p>因此要达成的目标是：加密传输（防窃听）、数字签名校验（防篡改）、身份证书（防冒充），基于这三个目标来了解TLS/SSL的工作原理就比较清晰了，能明确每一个部分设计的原因。</p>
<p>PS : HTTPS 默认端口为443，而HTTP默认端口为80</p>
<h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p>先来了解一下TLS/SSL的前世今生。</p>
<p>SSL(Secure Socket Layer)，由网景公司开发，3.0版本开始标准化为TLS。</p>
<p>TLS(Transport Layer Security)是SSL的标准化后的产物，有1.0 1.1 1.2三个版本，默认使用1.0</p>
<p>TLS是SSL的标准化后的产物，现在实际使用的是TLS，由于习惯原因仍经常称之为SSL。</p>
<h3 id="协议工作流程"><a href="#协议工作流程" class="headerlink" title="协议工作流程"></a>协议工作流程</h3><p>安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake），协议栈如下：</p>
<img src="/2019/12/01/HTTP/ssl protocal" alt="img" style="zoom:50%;">

<p>其中记录协议负责数据的分片、压缩、验证、加密等，握手协议负责客户端与服务端的握手，秘钥交换，告警等。整体流程如下图所示。</p>
<img src="/2019/12/01/HTTP/ssl handshake" alt="img" style="zoom:50%;">

<p>或者如下图所示：</p>
<img src="/2019/12/01/HTTP/ssl handshake 1" alt="img" style="zoom:50%;">



<p>简单的SSL握手连接过程(仅server端交换证书给client)，详情可见参考文献[3]：</p>
<ul>
<li><p>1.client发送ClientHello，指定版本，随机数(RN)，所有支持的密码套件(CipherSuites)</p>
<p>ClientHello附带的数据随机数据RN，会在生成session key时使用，Cipher suite列出了client支持的所有加密算法组合，每一组包含3种算法，一个是非对称算法，如RSA，一个是对称算法如DES，3DES，RC4等，一个是Hash算法，如MD5，SHA等，server会从这些算法组合中选取一组，作为本次SSL连接中使用。 </p>
</li>
<li><p>2.server回应ServerHello，指定版本，RN，选择CipherSuites，会话ID(Session ID)</p>
<p>ServerHello包含一个session id，如果SSL连接断开，再次连接时，可以使用该属性重新建立连接，在双方都有缓存的情况下可以省略握手的步骤。server端也会生成随机的RN，用于生成session key使用。server会从client发送的Cipher suite列表中挑出一个，例如RSA+RC4+MD5。</p>
</li>
</ul>
<p><strong>client接到ServerHello并处理后，双发状态是已经协商好了一组算法，包括对称加密、非对称加密、摘要，以及后续计算对称秘钥用的随机数</strong>。</p>
<ul>
<li><p>3.server发送Certificate<br>server的证书信息，只包含public key，server保存有public key对应的private key，用于证明server是该证书的实际拥有者。</p>
<p>那么如何验证呢？原理很简单：client随机生成一串数，用server的public key加密(显然是RSA算法)，发给server，server用private key解密后返回给client，client与原文比较，如果一致，则说明server拥有private key，也就说明与client通信的正是证书的拥有者。</p>
<p>利用这个原理，就可以实现session key的交换，加密前的那串随机数就可用作session key，因为除了client和server，没有第三方能获得该数据了。实际上session key的交换也是这么做的。<br>原理很简单，实际使用时会复杂很多，数据经过多次hash，伪随机等的运算，前面提到的client和server端得RN都会参与计算。这个原理用于下面client发送ClientKeyExchange前进行session key的计算。</p>
</li>
</ul>
<p><strong>client拿到了server的public key。</strong></p>
<ul>
<li><p>4.Server发送ServerHelloDone</p>
</li>
<li><p>5.client发送ClientKeyExchange，用于与server交换session key<br>client随机生成48字节的pre-master secret，padding后用public key加密得到130字节的数据发送给server，server解密也能得到pre-master secret。</p>
</li>
</ul>
<p>双方使用pre-master secret、”master secret”常量字节流、前期交换的server端RN和client的RN作为参数，使用一个伪随机函数PRF，其实就是hash之后再hash，最后得到48字节的master secret。master secret再与”key expansion”常量，双方RN经过伪随机函数运算得到key_block，PRF伪随机函数可以循环输出数据，因此我们想得到多少字节都可以，就如Random伪随机函数，给它一个种子，后续用hash计算能得到无数个随机数，如果每次种子相同，得到的序列是一样的，但是这里的输入时48字节的master secret，2个28字节的RN和一个字符串常量，碰撞的可能性是很小的。得到key block后，算法就从中取出session key，IV(对称算法中使用的初始化向量)等。client和server使用的session key是不一样的，但只要双方都知道对方使用的是什么就行了。这里会取出4个：client/server加密正文的key，client/server计算handshake数据hash的key。</p>
<p><strong>注意双方只交换了pre-master key，后续的计算都是独立完成的，由于算法和种子都一样，所以得到的session key也一致。</strong></p>
<p><strong>server接到ClientKeyExchange处理后，双方状态是已经协商好了对称秘钥，后续再利用对称秘钥进行一次验证</strong>。</p>
<ul>
<li><p>6.client发送ChangeCipherSpec，指示Server从现在开始发送的消息都是加密过的</p>
</li>
<li><p>7.client发送Finishd，包含了前面所有握手消息的hash，可以让server验证握手过程是否被第三方篡改</p>
<p>Finishd：client发送的加密数据，这个消息非常关键，一是能证明握手数据没有被篡改过，二能证明自己确实是session key的拥有者(这里是单边验证，只有server有certificate，server发送的Finished能证明自己含有private key，原理是一样的)。</p>
<p>client将之前发送的所有握手消息存入handshake messages缓存，进行MD5和SHA-1两种hash运算，再与前面的master secret和一串常量”client finished”进行PRF伪随机运算得到12字节的verify data，还要经过改进的MD5计算得到加密信息。为什么能证明上述两点呢，前面说了只有密钥的拥有者才能解密得到pre-master key，master key，最后得到key block后，进行hash运算得到的结果才与发送方的一致。</p>
</li>
<li><p>8.server发送ChangeCipherSpec，指示Client从现在开始发送的消息都是加密过的</p>
</li>
<li><p>9.server发送Finishd，包含了前面所有握手消息的hash，可以让client验证握手过程是否被第三方篡改，并且证明自己是Certificate密钥的拥有者（因为如果不是，那么无法得到pre-master key，也就无法计算得到session key），即证明自己的身份。</p>
</li>
</ul>
<p>握手完成后，客户端和服务端完成了对称秘钥session key的交换，数据通过对称秘钥加密后进行传输，实现了加密的数据传输通道。</p>
<h3 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h3><img src="/2019/12/01/HTTP/ca cert" alt="img" style="zoom:50%;">

<p>上面的握手流程讲完并没有描述数字证书扮演的角色，以及服务端向客户端返回证书，客户端进行验证的过程，这部分过程见上图。</p>
<p>服务端，即站点先向CA申请证书，申请信息中带有自己生成的公钥信息，CA审核通过后签发证书，证书包含服务端公钥、证书签名，证书签名为将证书明文部分计算数字摘要后，用CA的私钥加密的签名，防止证书被篡改（后面会讲到数字签名这块）。证书申请与签发是由站点先行完成的。</p>
<p>客户端在与服务端握手的过程中拿到证书，由于证书明文部分带有证书的公钥信息，能用CA的公钥对签名进行解密，并通过对比解密后的数字摘要与自己用明文计算的数字摘要来验证信息是否被篡改，从而保证了证书的安全性。后续通过证书中的server公钥来验证该server为证书拥有者，原理见上面的握手流程。</p>
<p>CA证书的安全使得客户端可以验证服务端的身份，防止站点被冒充，即钓鱼网站。</p>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>加密和解密使用相同的密钥，计算较快，安全性较差。在SSL中常用的对称加密算法有RC4,AES,3DES,Camellia等。</p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>加密和解密使用不同的密钥，数据在一端用公钥加密后，在另一端用私钥解密，安全性较高。由于性能问题，非对称加密一般用于数字签名（前面提到的证书的签名）和秘钥（对称加密算法的秘钥）的交换。常见的算法有RSA、DSA、ECC。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名就是“非对称加密+摘要算法”，其目的不是为了加密，而是用来防止他人篡改数据。<br>其核心思想是：比如A要给B发送数据，A先用摘要算法得到数据的指纹，然后用A的私钥加密指纹，加密后的指纹就是A的签名，B收到数据和A的签名后，也用同样的摘要算法计算指纹，然后用A公开的公钥解密签名，比较两个指纹，如果相同，说明数据没有被篡改，确实是A发过来的数据。假设C想改A发给B的数据来欺骗B，因为篡改数据后指纹会变，要想跟A的签名里面的指纹一致，就得改签名，但由于没有A的私钥，所以改不了，如果C用自己的私钥生成一个新的签名，B收到数据后用A的公钥根本就解不开。</p>
<p>至于为什么要使用摘要算法是因为非对称加密算法对原文长度有要求，所以先通过摘要算法生成一段较短的指纹，再进行非对称加密</p>
<h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>摘要算法不是用来加密的，其输出长度固定，相当于计算数据的指纹，主要用来做数据校验，验证数据的完整性和正确性。常见的算法有CRC、MD5、SHA1、SHA256。<br>CRC32:CRC本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。由于CRC32产生校验值时源数据块的每一个bit（位）都参与了计算，所以数据块中即使只有一位发生了变化，也会得到不同的CRC32值。</p>
<h1 id="HTTP-短连接-vs-长连接"><a href="#HTTP-短连接-vs-长连接" class="headerlink" title="HTTP 短连接 vs 长连接"></a>HTTP 短连接 vs 长连接</h1><p>下面来聊一下短连接与长连接。</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。HTTP的短连接、长连接实际上指的是TCP协议的短连接、长连接，长连接即是指多个HTTP请求复用一个TCP连接。</p>
<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等，当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<p>Connection:keep-alive 服务器和客户端都要设置</p>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><p>TCP连接的建立与释放分别对应的是三次握手与四次挥手，具体如下图：</p>
<img src="/2019/12/01/HTTP/tcp handshake" alt="img" style="zoom:75%;">





<img src="/2019/12/01/HTTP/tcp fin" alt="img" style="zoom:75%;">



<h1 id="HTTP-2-多路复用"><a href="#HTTP-2-多路复用" class="headerlink" title="HTTP/2 多路复用"></a>HTTP/2 多路复用</h1><p>详细可参考此文：<a href="https://blog.wangriyu.wang/2018/05-HTTP2.html，作者写的非常详细：）" target="_blank" rel="noopener">https://blog.wangriyu.wang/2018/05-HTTP2.html，作者写的非常详细：）</a></p>
<h6 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h6><p>[1] <a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>[2] <a href="https://blog.csdn.net/ustccw/article/details/76691248" target="_blank" rel="noopener">https://blog.csdn.net/ustccw/article/details/76691248</a></p>
<p>[3] <a href="https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html" target="_blank" rel="noopener">https://www.cnblogs.com/piyeyong/archive/2010/07/02/1770208.html</a></p>
<p>[4] <a href="https://blog.csdn.net/huangyuhuangyu/article/details/78220005" target="_blank" rel="noopener">https://blog.csdn.net/huangyuhuangyu/article/details/78220005</a></p>
<p>[5] <a href="https://blog.wangriyu.wang/2018/05-HTTP2.html" target="_blank" rel="noopener">https://blog.wangriyu.wang/2018/05-HTTP2.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">pcl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pcl</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
